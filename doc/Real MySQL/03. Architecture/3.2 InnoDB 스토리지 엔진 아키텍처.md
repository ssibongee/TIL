# 3.2 InnoDB 스토리지 엔진 아키텍처

<br>

- InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중에서 거의 유일하게 레코드 기반 잠금을 제공하고 있다.
- 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/065c67e4-382e-40fc-b373-94eef8b3432a/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F065c67e4-382e-40fc-b373-94eef8b3432a%2FUntitled.png?table=block&id=0313fdd8-5544-496c-8f4e-8877a6fc3ea4&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1250&userId=&cache=v2)

<br>



## 3.2.1 InnoDB 스토리지 엔진의 특성

- 프라이머리 키에 의한 클러스터링
  - InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
  - 프라이머리 키 값의 순서대로 저장된다는 의미이며 이로 인해 프라이머리 키에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다.
  - 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정된다.
  - 오라클 DBMS의 IOT (Index Organized Table)와 동일한 구조가 InnoDB에서는 일반적인 테이블 구조가 된다.
- 잠금이 필요없는 일관된 읽기 (Non-Locking Consistent Read)
  - InnoDB 스토리지 엔진은 MVCC (Multi Version Concurrency Control)라는 기술을 이용해 락을 걸지 않고 읽기 작업을 수행한다.
  - 락을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지 않는다.
- 외래 키 지원
  - 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
  - 외래 키는 여러 가지 제약사항으로 인해 실무에서는 잘 사용하지 않기 떄문에 필수적이지는 않지만 개발 환경의 데이터베이스에서는 좋은 가이드 역할을 할 수 있다.
  - InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하다.
  - 변경시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 없는지 확인해야 한다 하지만 이로 인해 잠금이 여러 테이블로 전파되고 데드락이 발생할 때가 많다.
- 자동 데드락 감지
  - InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지된다.
  - 감지된 데드락은 관련 트랜잭션 중에서 ROLLBACK이 가장 용이한 트랜잭션을 자동적으로 강제 종료해버린다.
  - 따라서 데드락 때문에 쿼리가 제한시간에 도달하거나 슬로우 쿼리로 기록되는 경우가 많지 않다.
- 자동화된 장애 복구
  - InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 매커니즘이 존재한다.
  - 매커니즘에 의해 MySQL서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.
- 오라클의 아키텍처 적용
  - InnoDB 스토리지 엔진의 기능은 오라클 DBMS의 기능과 상당히 비슷한 부분이 많다.
  - 대표적으로 MVCC 기능이 제공된다는 것과 Undo 데이터가 시스템 테이블 스페이스에 관리된다는 것 그리고 테이블 스페이스의 개념 등이 있으며 이외에도 상당히 흡사한 부분이 많다.



> 정리

- InnoDB는 레코드 기반의 락을 사용하며 높은 동시성 처리와 안정성과 성능을 제공한다.
- InnoDB는 프라이머리 키를 기준으로 데이터를 클러스터링 하여 저장한다.
- InnoDB는 MVCC (Multi Version Concurrency Control)을 이용하여 락을 걸지 않고 읽기 작업을 수행할 수 있다.
- InnoDB는 MyISAM이나 메모리 테이블에서 사용할 수 없는 외래키를 지원한다.
- 실무에서는 외래키를 여러가지 제약조건 때문에 잘 사용하지 않는지만 개발 환경에서는 좋은 가이드 역할을 할 수 있다.
- 외래키를 적용할 때에는 변경으로 인한 잠금이 여러 테이블로 전파되어 데드락이 발생할 수 있으므로 부모 자식 테이블에 데이터가 없는지 확인해야한다.
- InnoDB는 그래프 기반의 데드락 체크 방식을 이용해서 데드락이 발생함과 동시에 감지한다.
- InnoDB는 데드락이 발생한 트랜잭션 중에서 `ROLLBACK`이 용이한 트랜잭션을 자동으로 강제종료한다.
- InnoDB는 손실이나 장애로부터 데이터를 보호하기 위한 여러가지 매커니즘이 존재하며 장애 발생시 MySQL 서버가 재시작될 때 완료하지 못한 트랜잭션이나 데이터 페이지에 대한 복구작업이 자동 진행된다.
- InnoDB는 오라클 아키텍처를 적용하여 MVCC, 시스템 테이블 스페이스에서 Undo 데이터의 관리등 유사한 기능을 제공한다.



<br>



## 3.2.2 InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간이다.
- 쓰기작업을 지연시켜 일괄 처리할 수 있게 해주는 버퍼의 역할도 겸임한다.
- `INSERT`, `UPDATE`, `DELETE` 와 같이 데이터를 변경하는 쿼리는 랜덤한 디스크 작업을 발생시킨다.
- 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하게 되면 랜덤한 디스크 작업의 횟수를 줄일 수 있다.
- MyISAM의 키 캐시는 인덱스의 캐시만을 주로 처리한다.
- InnoDB의 버퍼 풀은 데이터와 인덱스를 모두 캐시하고, 쓰기 버퍼링의 역할까지 모두 수행한다.
- 버퍼 풀은 백그라운드 작업의 기반이되는 메모리 공간으로 버퍼 풀의 크기를 신중하게 설정하는 것이 좋다.
- 일반적으로 전체 물리 메모리의 50 ~ 80% 수준에서 버퍼 풀의 메모리 크기를 결정한다.
- 버퍼 풀은 아직 디스크에 기록되지 않은 변경된 데이터를 가지고 있다. 이러한 데이터를 가지고 있는 페이지를 더티 페이지라고 한다.
- 더티 페이지는 InnoDB에서 주기적으로 또는 어떤 조건에 따라 체크 포인트 이벤트가 발생하는데 이 때 쓰기 스레드가 필요한 만큼의 더티 페이지만 디스크로 기록한다.
- 체크 포인트가 발생한다고 해서 버퍼 풀의 모든 더티 페이지가 디스크로 기록되는 것은 아니다.



> 정리

- 버퍼 풀은 InnoDB의 가장 핵심적인 부분으로 디스크의 데이터 파일이나, 인덱스 정보를 메모리에 캐시해 두는 공간으로 쓰기 버퍼링의 역할까지 수행한다.
- 버퍼 풀은 백그라운드 작업의 기반이 되는 공간으로 일반적으로 물리 메모리 공간의 50 ~ 80% 수준에서 메모리 크기를 결정한다.
- 버퍼 풀은 아직 디스크에 기록되지 않은 더티 페이지를 가지고 있다가 주기적으로 또는 체크 포인트 이벤트 발생에 따라 필요한 만큼의 더티 페이지를 디스크로 기록한다.
- 해당 이벤트가 발생함에 따라 모든 더티 페이지가 디스크로 기록되는 것은 아니다.



<br>



## 3.2.3 Undo 로그

- Undo 영역은 `UPDATE` 문장이나 `DELETE` 와 같은 문장으로 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다.
- 데이터를 변경하는 쿼리가 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일 내용은 변경되고 Undo 영역에는 변경되기 전의 데이터가 백업된다.
- 이 상태에서 만약 사용자가 커밋하게 되면 현재 상태가 그대로 유지되고 롤백을 하게 되면 Undo 영역의 백업된 데이터를 다시 데이터 파일로 복구한다.
- Undo 영역은 크게 두 가지 용도로 사용되는데 첫 번째가 바로 트랜잭션의 롤백 대비용이다.
- 두 번째 용도는 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하는데 사용된다.
- 트랜잭션 격리 수준은 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보여질지를 결정하는 기준이다.



> 정리

- Undo 영역은 데이터를 변경했을 때 변경되기 전의 데이터를 보관하는 곳으로써 데이터를 변경하는 쿼리가 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일의 내용은 변경되고 Undo 영역에는 이전 데이터가 백업된다.
- 위의 상태에서 사용자가 커밋을 하게 되면 현재 상태가 그대로 유지되고 롤백을 하게 되면 Undo 영역의 백업된 데이터를 다시 데이터 파일로 복구한다.
- Undo 영역은 트랜잭션 롤백 대비용 뿐만 아니라 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공하기 위해 사용되는 영역이다.
- 트랜잭션 격리 수준이란 동시에 여러 트랜잭션이 데이터를 변경하거나 조회할 때 한 트랜잭션의 작업 내용이 다른 트랜잭션에 어떻게 보여질지를 결정하는 기준이다.



<br>



## 3.2.4 인서트 버퍼

- RDBMS에서 레코드가 `INSERT` 되거나 `UPDATE` 될 때는 데이터 파일을 변경하는 작업 뿐만 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.
- 인덱스를 업데이트하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 해당 작업은 많은 리소스를 소모하게 된다.
- InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 존재하면 바로 업데이트를 수행한다.
- 만약 디스크로부터 읽어와서 업데이트를 해야 한다면 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 된다.
- 이 때 사용하는 임시 메모리 공간을 인서트 버퍼라고 한다.
- 사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 인서트 버퍼를 사용할 수 없다.
- 인서트 버퍼에 임시로 저장되어 있는 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되며 이 스레드를 인서트 버퍼 머지 스레드라고 한다.
- MySQL 5.5 이전 버전까지는 `INSERT` 작업에 대해서 버퍼링이 가능했지만 이후 부터는 추가적으로 `DELETE` 작업에 대해서도 버퍼링이 될 수 있게 되었다.
- MySQL 5.5 버전부터는 `innodb_change_buffering` 이라는 파라미터가 추가되어 작업 종류별로 인서트 버퍼를 활성화할 수 있으며 비효율적일 때는 인서트 버퍼를 사용하지 않도록 설정할 수 있다.



> 정리

- `INSERT` , `UPDATE` , `DELETE` 등의 변경 작업은 데이터 파일을 변경하는 작업 뿐만 아니라 테이블의 인덱스를 업데이트 하는 작업도 수행해야 한다.
- 이 때 인덱스를 업데이트하는 작업은 디스크를 랜덤으로 읽는 작업이 필요하기 때문에 테이블에 인덱스가 많다면 많은 리소스를 소모하게 된다.
- InnoDB에서는 인서트 버퍼를 두어 변경해야할 인덱스 페이지가 버퍼 풀에 존재하면 바로 업데이트를 수행하고 디스크로 부터 읽어와야 한다면 인서트 버퍼에 저장해두고 먼저 사용자에게 결과를 반환한다.
- 중복 여부를 체크해야하는 유니크 인덱스는 버퍼를 사용할 수 없으며 인서트 버퍼에 저장된 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합된다.
- MySQL 5.5 버전부터는 `DELETE` 작업에 대해서도 버퍼링을 지원하며 사용자 설정에 따라 인서트 버퍼를 사용하지 않도록 할 수 있다.

<br>



## 3.2.5 Redo 로그 및 로그 버퍼

- 쿼리 문장으로 데이터를 변경하고 커밋하면 DBMS는 데이터의 ACID를 보장하기 위해 즉시 변경된 데이터의 내용을 데이터 파일로 기록해야 한다.
- 이러한 데이터 파일의 변경 작업은 순차적으로 많은 데이터를 한번에 변경하는 것이 아니고 랜덤하게 디스크에 기록해야 하기 때문에 디스크를 상당히 바쁘게 만든다.
- 이러한 부하를 줄이기 위해서 대부분의 DBMS는 변경된 데이터를 버퍼링해두기 위해 버퍼 풀과 같은 장치가 포함되어 있다.
- 하지만 이러한 장치 만으로는 ACID를 보장할 수 없는데 이를 위해 변경된 내용을 순차적으로 디스크에 기록하는 로그 파일을 가지고 있다.
- 이러한 로그 파일을 Redo 로그라고하며 DBMS에서 로그라고 하면 Redo 로그를 지칭하는 경우가 많다.
- Redo 로그 덕분에 DBMS 데이터는 버퍼링을 통해 한번에 디스크에 변경된 내용을 처리할 수도 있고 그로 인한 상당한 성능 향상을 기대할 수 있다.
- 변경 작업이 많은 DBMS의 경우 Redo 로그의 기록 작업이 큰 문제가 된다.
- 이를 보안하기 위해 ACID 속성을 보장하는 수준에서 버퍼링하게 되며 Redo 로그 버퍼링에 사용되는 공간이 로그 버퍼이다.
- 로그 버퍼의 크기는 일반적으로 1 ~ 8MB 수준에서 설정하는 것이 적합하며 만약 `BLOB` 이나 `TEXT` 와 같은 큰 데이터를 자주 변경하는 경우에는 더 크게 설정하는 것이 좋다.

### ACID

- ACID는 데이터베이스에서 트랜잭션의 무결성을 보장하기 위해 반드시 필요한 4가지 요소를 의미한다.
- 원자성 (Atomic)은 트랜잭션은 내부의 모든 작업은 하나의 작업처럼 수행되어야 함을 의미한다.
- 일관성 (Consistent)은 트랜잭션이 성공적으로 완료되면 언제나 일관된 상태로 데이터베이스를 유지하는 것을 의미한다.
- 격리성 (Isolated)은 트랜잭션 수행시 다른 트랜잭션의 작업이 중간에 끼어들지 못하도록 보장하는 것을 의미한다.
- 지속성 (Durable)은 성공적으로 수행된 트랜잭션은 영구적으로 반영되어야 함을 의미한다.



> 정리

- DBMS는 데이터가 변경되고 커밋됨에 따라서 ACID를 보장하기 위해 변경된 데이터의 내용을 즉시 데이터 파일로 기록해야 한다.
- 데이터 변경 작업은 순차적으로 많은 데이터를 한번에 변경하는 것이 아니고 랜덤하게 디스크에 기록되기 때문에 디스크에 부하를 가져온다.
- 이러한 부하를 줄이기 위해서 대부분의 DBMS는 변경된 데이터를 버퍼링하기 위해서 버퍼 풀과 같은 장치를 사용한다.
- 버퍼 풀만으로는 ACID를 보장할 수 없기 때문에 변경된 내용을 순차적으로 디스크에 기록하는 Redo로그라는 로그 파일을 가지고 있다.
- Redo 로그 덕분에 데이터는 버퍼링을 통해 한번에 디스크에 변경된 내용을 처리할 수도 있고 그로 인한 성능 향상을 기대할 수 있다.
- 변경 작업이 많은 DBMS의 경우에는 Redo 로그를 기록하는데 많은 리소스를 필요로한다.
- 이를 보안하기 위해 Redo 로그 버퍼링을 사용하며 이 때 사용되는 공간이 로그 버퍼이다.
- 로그 버퍼는 일반적으로 1 ~ 8MB 크기를 할당하며 `BLOB` 이나 `TEXT` 등의 대용량 데이터를 자주 변경한다면 더 크게 설정하는 것이 좋다.

<br>



## 3.2.6 MVCC (Multi Version Concurrency Control)

- 일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며 MVCC의 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기를 제공하는데 있다.
- InnoDB는 Undo 로그를 이용해 이 기능을 구현한다.
- Mutli Version이라는 의미는 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미이다.



<br>



### READ_COMMITED 트랜잭션 격리수준의 MySQL 서버에서 데이터 변경처리

- `INSERT INTO member (m_id, m_name, m_area) VALUES (12, 'Kim', 'Seoul')`
- `INSERT` 쿼리가 실행되면 데이터베이스의 상태는 다음과 같이 변경된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a1e1c81f-39af-4d19-8978-3aeddcab76a3/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fa1e1c81f-39af-4d19-8978-3aeddcab76a3%2FUntitled.png?table=block&id=807ae0e2-a40f-4f03-be29-e810254204a4&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1150&userId=&cache=v2)

InnoDB의 버퍼 풀과 데이터 파일의 상태

- `UPDATE member SET m_area='busan' WHERE m_id=12`
- `UPDATE` 쿼리가 실행될 때의 처리 과정은 다음과 같다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1d4ad4a-a068-4e7b-86df-64e42d08a312/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fb1d4ad4a-a068-4e7b-86df-64e42d08a312%2FUntitled.png?table=block&id=6194b4ba-66bc-4eb6-bece-0b57a48bf3ca&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1150&userId=&cache=v2)

UPDATE 후 InnoDB 버퍼 풀과 데이터 파일 및 Undo 영역의 변화

- InnoDB 특성상 버퍼 풀의 내용을 즉시 디스크의 데이터 파일로 기록하지 않고 일정 주기로 모아서 기록하기 때문에 `m_area` 컬럼 값은 `Seoul` 또는 `Busan` 일 수 있다.
- `UPDATE` 쿼리가 실행되면 커밋 실행 여부와 관계없이 InnoDB 버퍼 풀은 새로운 값으로 업데이트 된다.
- 디스크의 데이터 파일에는 체크포인트나 쓰기 스레드에 의해 새로운 값으로 업데이트되어 있을 수도 있고 아닐 수도 있다.
- `SELECT * FROM member WHERE m_id=12`
- `COMMIT` 이나 `ROLLBACK` 이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회하면 어디에 있는 데이터를 조회하는지는 MySQL 서버의 트랜잭션 격리 수준에 따라 달라진다.
- `READ_UNCOMMIED` 는 데이터의 커밋 여부와 상관없이 InnoDB 버퍼 풀 또는 데이터 파일로부터 변경된 상태의 데이터를 읽어서 반환한다.
- `READ_COMMITED` 또는 그 이상의 격리 수준인 경우에는 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 Undo 영역의 데이터를 반환한다.
- 이러한 과정을 DBMS에서는 MVCC라고 표현하며 하나의 레코드에 대해 여러가지 버전이 유지되고 필요에 따라 어느 데이터가 보여지는지 여러가지 상황에 따라 달라지는 구조이다.
- 관리해야하는 이전 버전의 데이터는 트랜잭션이 길어짐에 따라 삭제되지 못하고 오랫동안 관리되어야 하며 무한히 많아질 수 있다.
- 이에 따라 Undo 영역이 저장되는 시스템 테이블 스페이스 공간이 많이 늘어나야 하는 상황이 발생할 수 있다.
- 이 상태에서 `COMMIT` 명령어를 실행하면 InnoDB는 더 이상의 변경없이 현재 상태를 영구적인 데이터르 만들어버린다.
- 만약 `ROLLBACK` 을 실행한다면 Undo 영역에 있는 백업된 데이터를 버퍼 풀로 다시 복구하고 Undo 영역의 데이터를 삭제해버린다.
- `COMMIT` 이 된다고 Undo 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니며 Undo 영역을 필요로하는 트랜잭션이 존재하지 않을 때 삭제된다.



> 정리

- 레코드 기반 잠금을 제공하는 DBMS는 MVCC를 지원하며 MVCC를 통해 잠금을 사용하지 않는 일관된 읽기를 제공하는 것이 목적이다.
- MVCC는 Undo 로그를 이용하여 구현되며 Mutli Version이라는 의미는 하나의 레코드에 대해 여러개의 버전이 동시에 관리된다는 의미이다.
- `INSERT` , `UPDATE`, `DELETE` 등의 변경 쿼리가 발생하면 버퍼 풀의 데이터 파일이 변경되고 이전 데이터는 Undo 영역에 기록된다.
- `COMMIT` 및 `ROLLBACK` 이전에 조회하는 데이터는 트랜잭션의 격리 수준에 따라서 달라지며 `READ_COMMITED` 이상의 격리 수준에서는 Undo 영역의 데이터를 반환한다.
- 트랜잭션이 길어짐에 따라서 Undo 영역에서 관리되어지는 데이터가 많아지고 이에 따른 시스템 테이블 스페이스 공간이 늘어나야 하는 상황이 발생하여 최악의 경우 메모리 부족 현상이 발생할 수 있다.
- `COMMIT` 명령어가 실행되면 현재 상태를 영구적인 데이터로 만들어버리며 `ROLLBACK` 이 실행되면 Undo 영역의 백업 데이터를 다시 버퍼 풀로 복구하고 Undo 영역의 데이터를 삭제한다.
- `COMMIT` 이후에 Undo 영역의 데이터가 바로 삭제되는 것이 아니라 Undo 영역을 필요로하는 트랜잭션이 존재하지 않을 때 삭제된다.

<br>



## 3.2.7 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- InnoDB에서 `SERIALIZABLE` 이하의 트랜잭션 격리 수준에서는 `INSERT` 와 연결되지 않은 순수한 `SELECT` 작업은 다른 트랜잭션의 변경과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
- 특정 사용자가 레코드를 변경하고 아직 `COMMIT` 을 수행하지 않았다고 하더라도 변경 트랜잭션이 다른 사용자의 읽기 작업을 방해하지 않는다.
- 이러한 읽기 방법을 잠금 없는 일관된 읽기라고 표현하며 InnoDB에서는 변경 전의 데이터를 읽기 위해 Undo 로그를 사용한다.
- 오랜 기간 동안 활성 상태의 트랜잭션으로 인하여 MySQL 서버가 느려지거나 문제가 발생할때가 있는데 일관된 읽기를 위한 Undo 로그를 삭제하지 못하고 계속 유지해야하기 때문에 발생하는 문제이다.
- 때문에 트랜잭션이 시작되었다면 가능한 빨리 `ROLLBACK` 이나 `COMMIT` 을 통해 트랜잭션을 완료하는 것이 좋다.



> 정리

- InnoDB는 앞서 설명한 MVCC로 인하여 `SERIALIZABLE` 이하의 격리 수준에서 순수한 읽기 작업은 다른 트랜잭션의 변경과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
- 잠금 없는 일관된 읽기를 위해 읽기 작업은 Undo 로그 사용하여 이전에 기록된 데이터를 읽게 된다.
- 하지만 이 때 활성 트랜잭션이 오랜기간 지속됨에 따라서 Undo 로그의 데이터가 삭제되지 못하고 계속 유지되어 서버가 느려지거나 문제가 발생할 수 있는데 때문에 트랜잭션은 가능한 빨리 완료하는 것이 좋다.



<br>



## 3.2.8 InnoDB와 MyISAM 스토리지 엔진 비교

- MySQL5.5 버전부터는 InnoDB 스토리지 엔진이 기본 스토리지 엔진으로 채택되었다.
- MyISAM 스토리지 엔진은 인덱스를 위한 키 캐시를 가지고 있지만 데이터 자체는 운영체제의 캐시에 의존한다.
- 반면에 InnoDB 스토리지 엔진은 자체적인 버퍼 풀을 가지고 있어서 좀 더 업무 특성에 맞는 캐싱이나 버퍼링을 수행한다.
- 트랜잭션 관리 뿐만 아니라 레코드 수준의 잠금 관리로 인해 MyISAM에 비해 높은 동시성 성능을 제공한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3e06b1b1-2d56-4639-9171-00b3e074baf4/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3e06b1b1-2d56-4639-9171-00b3e074baf4%2FUntitled.png?table=block&id=38f736c9-e256-4495-bc1d-44aa581d7e39&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=2160&userId=&cache=v2)

- InnoDB의 단 한가지 단점이라고 하면 MyISAM 보다 MySQL 서버의 설정 튜닝이 까다롭다는 것을 제외하고는 InnoDB와 MyISAM은 비교가 무의미할 정도의 성능차를 보인다.
- 특히 보조 인덱스 스캔과 범위 스캔 풀 스캔에 대해서는 InnoDB가 엄청난 성능차이를 보인다.



> 정리

- MySQL 5.5 버전부터 InnoDB를 기본 스토리지 엔진으로 사용하고 있다.
- InnoDB는 MyISAM이 인덱스를 위한 키 캐시만을 지원하는 것에 반하여 데이터 파일 및 인덱스 정보를 캐싱하고 쓰기 버퍼링의 역할까지 수행하는 버퍼 풀을 지원한다.
- InnoDB는 트랜잭션 관리 뿐만 아니라 레코드 기반 잠금을 제공하여 높은 수준의 동시성 성능을 제공한다.



<br>



## 3.2.9 InnoDB와 Memory (Heap) 스토리지 엔진 비교

- Memory 스토리지 엔진의 가장 큰 장점은 데이터와 인덱스를 모두 메모리에 저장하기 때문에 매우 빠른 속도의 저장 및 읽기 작업이 가능하다.
- 하지만 Memory 스토리지 엔진을 사용하는 테이블은 레코드 수준의 잠금이 아니라 테이블 수준의 잠금을 이용한다.
- 때문에 둘 이상의 클라이언트가 테이블을 동시에 변경할 수 없다.
- 이러한 동시성 때문에 Memory 스토리지 엔진은 빠른 쓰기와 읽기 작업이 가능함에도 불구하고 벤치마킹 결과 InnoDB 스토리지 엔진이 더 높은 성능을 보여준다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/488b2ac7-0aca-41aa-8b7f-ae3f072584e8/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F488b2ac7-0aca-41aa-8b7f-ae3f072584e8%2FUntitled.png?table=block&id=33ca2bc8-fdf3-44a0-8f8a-df38f7f34370&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=2260&userId=&cache=v2)

- 벤치마크 결과에서도 알 수 있듯이 메모리가 충분하다면 테이블 수준의 잠금을 사용하는 Memory 스토리지 엔진보다 레코드 수준의 잠금을 사용하는 InnoDB 스토리지 엔진이 훨씬 더 빠른 트랜잭션 처리를 보장해준다.
- Memory 테이블은 여러 커넥션에 의해 읽기 위주로 사용되는 경우 또는 단일 커넥션으로 사용될 때 적합하지만 동시에 많은 커넥션이 트랜잭션을 유발하는 OLTP 환경에서는 적합하지 않다.



> 정리

- Memory 스토리지 엔진은 메모리에 데이터와 인덱스를 저장하기 때문에 빠른 읽기와 쓰기 작업이 가능하지만 테이블 수준의 잠금을 제공하기 때문에 낮은 동시성을 제공한다.
- 때문에 여러 커넥션이 동시에 트랜잭션을 유발하는 OLTP 환경에서는 적합하지 않으며 메모리가 충분하다면 레코드 수준의 잠금을 제공하는 InnoDB 스토리지 엔진이 훨씬 더 빠른 성능을 보인다.
