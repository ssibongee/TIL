# 3.1 MySQL 아키텍처

- MySQL은 다른 DBMS에 비해서 독특한 구조를 가진다



<br>





## 3.1.1 MySQL 전체 구조

<br>



![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7e80ace2-9b8c-493b-b2a5-5ff37a99c2a1/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F7e80ace2-9b8c-493b-b2a5-5ff37a99c2a1%2FUntitled.png?table=block&id=f16be72e-4744-4c5f-b049-b85dc595d920&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1340&userId=&cache=v2)

<br>



- MySQL은 상용 DBMS에서 제공하는 대부분의 접근법을 모두 지원한다.
- 각종 프로그래밍 언어에 대한 표준 드라이버를 제공하며 해당 언어를 이용해 MySQL 서버에서 쿼리를 사용할 수 있도록 지원한다.
- MySQL 서버는 크게 MySQL엔진과 스토리지 엔진으로 구분할 수 있다.
- MySQL 엔진
  - 클라이언트로부터 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL파서 및 전처리기와 쿼리 최적화를 위한 옵티마이저가 중심을 이룬다.
  - 성능향상을 위해 MyISAM의 Key 캐시나 InnoDB의 Buffer Pool과 같은 보조 저장소 기능이 포함되어 있다.
  - MySQL은 표준 ANSI 문법을 지원하기 때문에 표준 문법에 따라 작성된 타 DBMS와 호환되어 실행될 수 있다.
  - MySQL 엔진은 요청된 SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.
- 스토리지 엔진
  - 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 스토리지 엔진이 전담한다.
  - MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
  - `CREATE` 로 테이블을 생성할 때 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 읽기나 변경 작업은 정의된 스토리지 엔진이 처리한다.
- 핸들러 API
  - MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각각의 스토리지 엔진에게 쓰기 또는 읽기를 요청하는데 이를 핸들러 요청이라고 하며 이 때 사용되는 API를 핸들러 API라고 한다.
  - InnoDB 스토리지 엔진 또한 핸들러 API를 이용해서 MySQL 엔진과 데이터를 주고 받는다.
  - 핸들러 API를 통해 얼마나 작은 작업이 있었는지 확인하는 명령어는 다음과 같다.
    - `SHOW GLOBAL STATUS LINKE 'Handler%'`



> 정리

- MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분되어진다.
- MySQL 엔진은 클라이언트로 부터 요청된 SQL 문장을 분석하거나 최적화 하는 등의 역할을 수행한다.
- 스토리지 엔진은 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 역할을 수행한다.
- MySQL 엔진과 스토리지 엔진 사이에 데이터를 주고 받는 요청은 핸들러 API를 통해 이루어진다.



<br>



## 3.1.2 MySQL 스레딩 구조

<br>

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ad22be3-058e-4b23-acfa-e96fc9aba321/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F6ad22be3-058e-4b23-acfa-e96fc9aba321%2FUntitled.png?table=block&id=b4aa27a4-5d03-401a-b925-3a16b496c904&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1060&userId=&cache=v2)

<br>



- MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.
- 포그라운드 스레드 (클라이언트 스레드)
  - 포그라운드 스레드는 최소 MySQL에 접속된 클라이언트의 수 만큼 존재한다.
  - 주로 각 클라이언트 사용자가 요청하는 문장을 처리하는 것이 역할이다.
  - 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 풀로 돌아간다.
  - 이 때 이미 스레드 풀에 일정 개수 이상 대기중인 스레드가 있으면 스레드 풀에 넣지 않고 스레드를 종료시켜 스레드 풀에 일정 개수를 유지한다.
  - 이 때 스레드 개수를 유지하는 파라미터가 `thread_cache_size` 이다.
  - 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져온다.
  - 버퍼나 캐시에 존재하지 않는 경우 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.
  - MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리한다.
  - InnoDB 테이블은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.
- 백그라운드 스레드
  - InnoDB 스토리지 엔진은 여러 가지 작업이 백그라운드로 처리된다.
    - 인서트 버퍼를 병합하는 스레드
    - 로그를 디스크로 기록하는 스레드
    - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
    - 데이터를 버퍼로 읽어들이는 스레드
    - 여러가지 잠금이나 데드락을 모니터링하는 스레드
    - 모든 스레드를 총괄하는 메인 스레드
  - 가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 쓰는 작업을 처리하는 쓰기 스레드이다.
  - 쓰기 스레드의 개수를 지정하는 파라미터는 `innodb_write_io_threads` 이며 읽기 스레드의 개수를 지정하는 파라미터는 `innodb_read_io_threads` 이다.
  - InnoDB에서 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없다.
  - 쓰기 스레드의 경우 아주 많은 작업을 백그라운드로 처리하기 때문에 충분히 설정해 해당 스토리지 장비가 충분히 활용될 수 있게 하는 것이 좋다.
- SQL 처리 도중 데이터의 쓰기 작업은 버퍼(지연)되어 처리될 수 있지만 읽기 작업은 절대로 지연될 수 없다.
- 상용 DBMS에서는 대부분 쓰기 작업을 버퍼링해서 일괄적으로 처리하는 기능이 탑재되어 있으며 InnoDB 또한 이러한 방식으로 처리한다.
- MyISAM은 클라이언트 스레드가 쓰기 작업까지 함께 처리하도록 설계되어있다.
- InnoDB에서는 `INSERT` , `UPDATE` , `DELETE` 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 된다.
- MyISAM에서는 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.



> 정리

- MySQL 서버는 스레드 기반으로 동작하며 크게 포그라운드 스레드와 백그라운드 스레드로 나누어진다.
- 포그라운드 스레드는 클라이언트 스레드로 최소 MySQL에 접속한 클라이언트 수 만큼 유지된다.
- 포그라운드 스레드는 스레드 풀에서 관리되며 사용자의 커넥션의 시작과 종료에 따라서 해당 커넥션 풀에서 스레드를 가져오고 반납한다.
- 포그라운드 스레드는 버퍼나 캐시에 데이터를 1차로 조회하며 존재하지 않을 경우 디스크나 인덱스 파일로부터 데이터를 읽어와서 작업을 처린한다.
- InnoDB의 경우 버퍼나 캐시 까지만 포그라운드 스레드가 처리하고 나머지 버퍼로 부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.
- 버퍼나 캐시로 부터 데이터를 읽는 작업 외에 대부분의 쓰기 작업이나 기타 작업은 백그라운드 스레드에서 수행된다.
- 로그와 버퍼의 데이터를 쓰는 스레드가 가장 중요하며 쓰기 스레드의 경우 아주 많은 작업을 백그라운드로 처리하기 때문에 적절한 스레드의 개수 설정이 필요하다.
- SQL의 쓰기 작업은 버퍼나 캐시 등에 1차 적으로 저장되었다가 지연되어 처리될 수 있지만 읽기 작업은 절대로 지연되서 처리될 수 없다.
- InnoDB의 경우에도 쓰기작업은 버퍼링해서 일괄적으로 처리한다.

<br>



## 3.1.3 메모리 할당 및 사용 구조

<br>

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf8ed440-caf9-4f92-94d4-9ea7bcad3a65/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fcf8ed440-caf9-4f92-94d4-9ea7bcad3a65%2FUntitled.png?table=block&id=ccc4d610-f3d7-419f-94c4-9010fb1bb16d&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=2240&userId=&cache=v2)

<br>

- MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.
- 글로벌 메모리 영역은 모든 메모리 공간의 MySQL 서버가 시작되면서 무조건 운영체제로부터 할당된다.
- 글로벌 메모리 영역과 로컬 메모리 영역의 차이는 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는 공간인지 아닌지에 따라 구분된다.
- 글로벌 메모리 영역
  - 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당된다.
  - 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와는 무관하며 생성된 글로벌 영역은 모든 스레드에 의해 공유된다.
- 로컬 메모리 영역 (세션 메모리 영역)
  - MySQL 서버상 존재하는 클라이언트 스레드가 쿼리를  처리하는데 사용되는 메모리 영역이다.
  - 대표적으로 커넥션 버퍼와 정렬 버퍼 등이 있다.
  - 클라이언트가 MySQL 서버에 접속하면 MySQL 서버에서는 클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드를 하나씩 할당하게 된다.
  - 클라이언트 스레드가 사용하는 메모리 공간이기 때문에 클라이언트 메모리 영역이라고도 한다.
  - 클라이언트와 MySQL 서버와의 커넥션을 세션이라고도 하기 때문에 세션 메모리 영역이라고도 한다.
  - 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당이되며 절대 공유되어 사용되지 않는다.
  - 로컬 메모리 영역을 잘못 할당하는 경우 MySQL 서버가 메모리 부족으로 멈춰버릴 수 있기 때문에 적절한 메모리 공간 할당이 필요하다.
  - 로컬 메모리 공간은 쿼리의 용도별로 필요할때만 공간이 할당되고 필요하지 않는 경우에는 메모리 공간을 할당하지 않을 수 있다.
  - 로컬 메모리 공간은 커넥션이 연결되어있는 동안 계속 할당된 상태로 남아있는 공간이 있고 (커넥션 버퍼, 결과 버퍼)
  - 쿼리를 실행하는 순간에만 할당했다가 해제하는 공간이 (소트 버퍼, 조인 버퍼) 있다.
- MySQL의 독특한 구조 중 대표적인 것이 플러그인 모델이며 필요에 따라 특정 기능을 수행하는 플러그를 제작하는 것이 가능하다.
- MySQL에서 쿼리가 실행되는 과정을 살펴보면 대부분의 SQL 파싱, 옵티마이징, 실행 등은 MySQL 엔진 영역에서 처리되며 데이터 읽기 쓰기 작업만 스토리지 엔진에 의해 처리된다.
- MySQL에서 어떠한 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도 MySQL의 처리내용은 대부분 동일하며 데이터 읽기 쓰기 영역의 처리만 차이가 존재한다.
- 실질적인 `ORDER BY` 나 `GROUP BY` 등의 많은 복잡한 처리는 MySQL 엔진 영역의 쿼리 실행기에서 처리된다.



> 정리

- MySQL의 메모리 구조는 크게 글로벌 영역과 로컬 영역으로 나누어진다.
- 글로벌 영역은 모든 클라이언트 스레드에 의해서 공유되는 영역을 의미한다.
- 로컬 메모리 영역은 세션 또는 클라이언트 메모리 영역이라고도 하며 MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용되는 메모리 영역이다.
- 로컬 메모리 영역은 클라이언트 스레드 마다 하나씩 할당되며 절대 다른 스레드와 공유되지 않는다.
- 로컬 메모리 공간은 커넥션이 연결되어있는 동안 계속 할당된 상태로 남아있는 공간과 쿼리를 실행하는 순간에만 할당했다가 해제하는 공간으로 나누어진다.
- MySQL에서 쿼리가 실행되는 과정의 대부분은 MySQL 엔진에 의해 처리되며 데이터를 읽고 쓰는 작업만 스토리지 영역에서 수행된다.

<br>

## 3.1.5 쿼리 실행구조

<br>

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/565d28df-2322-4195-bf55-9433330f0fdd/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F565d28df-2322-4195-bf55-9433330f0fdd%2FUntitled.png?table=block&id=5c809ec0-4912-4de2-a9e7-944546cec056&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1910&userId=&cache=v2)

<br>

- 파서 (Query Parser)
  - 사용자 요청으로 들어온 쿼리 문장을 토큰 (MySQL이 인식할 수 있는 최소 단위)으로 분리해 트리 형태의 구조로 만들어 내는 작업을 한다.
  - 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되며 사용자에게 오류 메세지를 전달하게 된다.
- 전처리기 (Preprocessor)
  - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.
  - 각 토큰을 테이블 이름이나 컬럼 이름 또는 내장 함수와 같은 객체를 매핑하여 해당 객체의 존재 여부와 객체 접근권한 등을 확인한다.
  - 실제 존재하지 않거나 권한상 사용할 수 없는 객체의 토큰은 이 단계에서 걸러진다.
- 옵티마이저 (Optimizer)
  - 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당한다.
- 실행 엔진 (Query Processor)
  - 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러의 요청의 입력으로 연결하는 역할을 수행한다.
- 핸들러 (Storage Engine)
  - 핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당한다.
  - 각각의 스토리지 엔진이 핸들러가 된다.

<br>

## 3.1.6 복제 (Replication)

<br>

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d2891ce5-1d40-4624-abd5-60149f553e33/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd2891ce5-1d40-4624-abd5-60149f553e33%2FUntitled.png?table=block&id=0aea6199-5b6d-48dc-9730-8b871db96a40&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1730&userId=&cache=v2)

<br>

- 빅데이터 시대가 도래함에 따라서 DBMS에서 확장성은 매우 중요한 요소이다.
- MySQL은 확장성을 위해 복제 (Replication)을 제공하는데 복제는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다.
- MySQL 복제에는 `INSERT` , `UPDATE` 같은 쿼리를 사용해서 데이터를 변경할 수 있는 서버와 `SELECT` 쿼리로 데이터를 읽기만 할 수 있는 서버로 나누어진다.
- MySQL에서는 쓰기와 읽기로 역할을 구분하여 쓰기를 위한 서버를 마스터라고 하고 읽기를 위한 서버를 슬레이브라고 한다.
- MySQL 서버의 복제에서 마스터는 반드시 1개이며 슬레이브는 1개 이상으로 구성될 수 있다.
- 하나의 MySQL이 일반적으로 마스터 또는 슬레이브 하나의 역할을 수행하지만 때로는 서버 하나가 마스터이면서 슬레이브 역할까지 수행하도록 설정할 수 있다.
- 마스터 (Master)
  - MySQL의 바이너리 로그가 활성화되면 어떤 MySQL 서버도 마스터가 될 수 있다.
  - 애플리케이션 입장에서 보면 마스터는 주로 데이터가 생성 및 변경, 삭제되는 주체라고 볼 수 있다.
  - 일반적으로 MySQL 복제를 구성하는 경우 복제에 참여하는 여러 서버 가운데 변경이 허용되는 서버는 마스터로 한정할 때가 많다.
  - 그렇지 않을 경우 데이터 일관성을 보장하기 어렵기 때문이다.
  - 마스터 서버에서 실행되는 DML과 DDL 가운데 데이터의 구조나 내용을 변경하는 모든 쿼리 문장은 바이너리 로그에 기록된다.
  - 슬레이브 서버에서 변경 내역을 요청하면 마스터 장비는 해당 바이너리 로그를 읽어 슬레이브로 전달한다.
  - 마스터 서버의 프로세스 가운데 `Binlog dump` 라는 스레드가 해당 일을 전담하는 스레드이다.
  - 하나의 마스터 서버에 N개의 슬레이브가 연결되어있다면 `Binlog dump` 스레드는 N개가 표시된다.
- 슬레이브 (Slave)
  - 바이너리 로그를 받아 올 마스터 장비의 정보를 가지고 있는 경우 슬레이브가 된다.
  - 마스터 서버가 바이너리 로그를 가지고 있다면 슬레이브 서브는 릴레이 로그를 가지고 있다.
  - 마스터와 슬레이브의 데이터를 동일한 상태로 유지하기 위해서 슬레이브 서버는 읽기 전용으로 설정할 때가 많다.
  - 슬레이브 서버의 IO 스레드는 마스터 서버에 접속해 변경 내역을 요청하고 받아온 변경 내역을 릴레이 로그에 기록한다.
  - 슬레이브 서버의 SQL 스레드가 릴레이 로그에 변경된 내역을 재실행함으로써 마스터와 슬레이브의 데이터를 동일한 상태로 유지한다.

<br>

### 복제 (Replication)를 사용할 때 주의할 사항

- 슬레이브는 하나의 마스터만 설정 가능하다.
  - MySQL의 복제에서 하나의 슬레이브는 하나의 마스터만 가질 수 있다.
  - 하나의 마스터에 N개의 슬레이브가 일반적인 형태이며 그 밖에 링이나 트리 형태로 구성할 수 있다.
  - 마스터와 마스터 형태로 복제도 사용가능한데 이 때 각각의 서버가 모두 마스터이면서 슬레이브가 되는 형태로 구성된다.
- 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정한다.
  - 마스터와 슬레이브로 복제가 구성된 상태에서 데이터는 마스터로 접속해서 변경해야 한다.
  - 사용자의 실수나 애플리케이션의 오류로 인해 슬레이브로 접속해서 실행하는 경우가 발생한다.
  - 이 때 일부 변경작업이 마스터에서 실행되고 일부는 슬레이브에서 실행된다면 데이터 동기화에 상당한 비용이 발생할 것이다.
  - 이러한 실수를 막기 위해 슬레이브는 읽기 전용으로 설정하는 것이 일반적이다.
- 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합하다.
  - 마스터 서버에서 수많은 동시 사용자가 실행한 데이터 변경 쿼리 문장이 슬레이브 서버에서 하나의 스레드로 모두 처리되어야 한다.
  - 변경이 매우 잦은 MySQL 서버일 경우 슬레이브 서버의 사양이 더 좋아야 마스터에서 동시에 여러 개의 스레드로 실행된 쿼리가 슬레이브에서 지연되지 않고 하나의 스레드로 처리될 수 있다.
  - 데이터 변경은 조회보다 1/10 수준으로 유지되는 것이 일반적이므로 마스터 서버와 슬레이브 서버를 같은 사양으로 유지할 때가 많다.
  - 슬레이브 서버는 마스터 서버가 다운된 경우 복구 대안으로 사용할 경우도 많기 때문에 사양을 동일하게 맞추는 것이 일반적이다.
- 복제가 불필요한 경우에는 바이너리 로그를 중지한다.
  - 바이너리 로그를 작성하기 위해서 MySQL은 많은 자원을 소모하고 이에 따른 성능 저하가 발생된다.
  - 바이너리 로그를 안정적으로 기록하기 위해 `GAP_LOCK` 을 유지하고 매번 트랜잭션이 커밋될 때마다 데이터를 변경시킨 쿼리 문장을 바이너리 로그에 기록해야 한다.
  - 바이너리 로그를 기록하는 작업을 Auto Commit이 활성화 된 MySQL 서버에서 더 심각한 부하로 나타날 때가 많다.
  - 특히 트랜잭션을 지원하지 않는 MyISAM 테이블은 항상 Auto Commit 모드로 동작하기 때문에 InnoDB 테이블보다 바이너리 로그를 기록하는데 더 많은 자원을 사용한다.
- 바이너리 로그와 트랜잭션 격리수준
  - 바이너리 로그 파일은 어떤 내용이 기록되느냐에 따라서 `STATEMENT` 포맷 방식과 `ROW` 포맷 방식으로 나누어진다.
  - `STATEMENT` 방식은 바이너리 로그 파일에 마스터에서 실행되는 쿼리 문장을 기록하는 방식이다.
  - `ROW` 방식은 마스터에서 실행된 쿼리에 의해 변경된 레코드 값을 바이너리 로그에 기록하는 방식이다.
  - `STATEMENT` 방식에서는 마스터와 슬레이브의 데이터 일치를 위해 `REPEATABLE_READ` 수준의 격리 수준만 사용가능하다.
  - SQL 기반 복제인 `STATMENT` 방식에서는 아무리 데이터의 변경을 많이 유발하는 쿼리라고 하더라도 SQL문장 하나만 슬레이브로 전달되기 때문에 네트워크 트래픽을 많이 유발하지 않는다.
  - SQL 기반의 복제가 정상적으로 작동하려면 `REPEATABLE_READ` 이상의 트랜잭션 격리 수준을 사용해야 한다.
  - 이로 인해 InnoDB 테이블에서는 레코드 사이의 간격을 잠그는 `GAP_LOCK` 이나 `NEXT_KEY_LOCK` 이 필요하다.
  - 반면 레코드 기반 복제는 마스터와 슬레이브 서버 간의 네트워크 트래픽을 많이 발생시킬 수 있지만 `READ_COMMITED` 격리수준에서도 동작할 수 있으며
  - InnoDB 테이블에서의 잠금에 대한 경합은 줄어들게 된다.



> 정리

- MySQL에서는 데이터베이스의 확장성을 위해 복제를 지원한다.
- 일반적으로 1개의 마스터 서버와 N개의 슬레이브 서버로 구성되며 마스터 서버는 데이터 변경을 수행하고 슬레이브 서버는 읽기 전용 서버로 구성된다.
- 마스터 서버에서 변경 내역은 바이너리 로그에 저장되며 슬레이브 서버에서 IO 스레드로 해당 변경내용을 요청하면 바이너리 로그에 저장된 변경내역이 슬레이브 서버의 릴레이 로그에 저장된다.
- 슬레이브 서버는 SQL 스레드로 릴레이 로그에 기록된 쿼리를 재실행함으로써 마스터 서버와의 동기화를 수행한다.
- 슬레이브는 하나의 마스터 서버만 설정할 수 있으며 마스터 서버와 동일한 사양으로 설정하는 것이 적합하다.
- 바이너리 로그를 기록하는 작업은 많은 서버 리소스를 사용하고 이에 따른 성능 저하가 발생하기 때문에 복제를 사용하지 않는 경우에 해당 기능을 사용하지 않는 것이 좋다.
- 바이너리 로그는 SQL을 기록하는 방식과 레코드를 기록하는 방식으로 나누어진다.
- SQL을 기록하는 방식은 적은 네트워크 트래픽을 필요로 하지만 SQL 기반 복제를 정상적으로 수행하기 위해 `REPEATABLE_READ` 이상의 격리 수준을 필요로 하며 이로 인한 `GAP_LOCK` 과 같은 잠금 방식이 필요하다.
- 레코드를 기록하는 방식은 많은 네트워크 트래픽을 발생시킬 수 있지만 `READ_COMMIT` 격리 수준에서도 동작할 수 있으며 이로 인한 테이블 잠금 경합이 줄어들게 된다.

<br>



## 3.1.7 쿼리 캐시

<br>

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3e7d91f6-5413-4871-9667-f570839ca3d2/Untitled.png](https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F3e7d91f6-5413-4871-9667-f570839ca3d2%2FUntitled.png?table=block&id=f2e0808d-3f03-4954-91db-d95f318e5bb0&spaceId=5723e4f7-61fe-4e85-9214-fdffa6ca70b4&width=1440&userId=&cache=v2)

<br>

- 쿼리 캐시는 다른 DBMS에는 없는 MySQL의 독특한 기능 중 하나로써 적절한 설정을 통해 상당한 성능 향상을 얻을 수 있다.
- 실행된 결과를 쿼리 캐시에 담아두고 동일한 쿼리 요청이 왔을 때 간단하게 쿼리 캐시에서 찾아서 바로 결과를 반환할 수 있다.
- 쿼리 캐시에는 항상 장점만 존재하는 것이 아니기 때문에 적절한 조율이 필요하다.
- 쿼리 캐시는 단어의 의미와는 달리 SQL 문장을 캐시하는 것이 아니라 쿼리 결과를 메모리에 캐싱하는 기능이다.
- 쿼리 캐시의 구조는 Key와 Value의 쌍으로 관리되는 맵과 같은 데이터 구조로 구현되어 있다.
- Key를 구성하는 요소 가운데 가장 중요한 것은 쿼리 문장 자체이며 이 때 Value는 쿼리의 실행 결과이다.
- 데이터베이스에서 쿼리를 처리할 때 상당히 많은 부분의 처리 절차가 존재한다. 때문에 동일한 쿼리 요청이 왔다고 해서 그냥 캐싱된 데이터를 반환하면 안된다.
- 쿼리 캐시에 캐싱된 데이터를 반환하기 위해서는 다음과 같은 확인 절차를 거쳐야 한다.
  - 요청된 쿼리 문장이 쿼리 캐시에 존재하는가 (존재 여부 확인)
  - 해당 사용자가 결과를 볼 수 있는 권한을 가지고 있는가 (권한 확인)
  - 트랜잭션 내에서 실행된 쿼리의 경우 결과가 가시 범위 내의 트랜잭션에서 만들어진 결과인가 (결과의 가시성 확인)
  - 쿼리에 사용된 기능이 캐시되어도 동일한 결과를 보장할 수 있는가 (호출 시점에 달라지는 데이터가 있는지 확인)
    - PreparedStatement의 경우 변수가 결과에 영향을 미치지 않는지
  - 캐시가 만들어지고 난 이후 데이터가 다른 사용자에 의해 변경되지 않았는지 (데이터의 변경여부 확인)
  - 쿼리에 의해 만들어진 결과가 캐시에 저장하기 크지 않은지 (데이터의 적합성 확인)
  - 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용되었는지

<br>



### 쿼리 캐시를 사용하기 위해 고려해야 할 사항

- 요청된 쿼리 문장이 쿼리 캐시에 존재하는가
  - 쿼리 캐시는 MySQL의 가장 앞에 위치하며 캐시된 결과를 찾기 위해 쿼리 문장을 분석, 비교하는 복잡한 과정을 거치지 않기 때문에 빠르게 진행된다.
  - 이 때 비교방식은 쿼리 문장 자체가 동일한지 여부를 비교하며 비교 대상으로는 공백과 탭과 같은 문자를 모두 포함하며 대소문자까지 잋리해야 동일한 쿼리로 인식한다.
- 해당 사용자가 그 결과를 볼 수 있는 권한을 가지고 있는가
  - 어떤 사용자가 요청한 쿼리에 대해 동일한 결과가 쿼리 캐시에 저장되어 있다고 하더라도 사용자가 해당 테이블에 대한 권한을 가지고 있지 않으면 결과를 반환해서는 안된다.
- 트랜잭션 내에서 실행된 쿼리의 경우 가시범위 내에 있는 결과인가
  - InnoDB의 모든 트랜잭션은 각 트랜잭션 ID를 가지게 되며 트랜잭션 ID는 트랜잭션 시작 시점을 기준으로 순차적으로 증가하는 값으로 이 값을 비교하여 먼저 시작된 트랜잭션을 구분할 수 있다.
  - InnoDB에서는 트랜잭션 격리 수준을 준수하기 위해서 각 트랜잭션은 자신의 ID보다 큰 트랜잭션에서 변경한 작업 내용이나 쿼리 결과를 참조할 수 없다.
  - 이를 트랜잭션의 가시 범위라고 하며 쿼리 캐시도 그 결과를 만들어낸 트랜잭션의 ID가 가시범위 내에 존재할 때만 사용할 수 있다.
- `CURRENT_DATE` , `SYSDATE` , `RAND`  등과 같이 호출 시점에 따라 결과가 달라지는 요소를 포함하고 있는가
  - 해당 함수들을 동일한 사용자가 동일한 쿼리를 실행하더라도 호출하는 시간에 따라 결과가 달라진다.
  - 호출될 때마다 결과가 달라지는 내장함수로 정의된 함수등은 사용하지 않는 편이 쿼리 캐시의 효율을 높일 수 있다.
- PreparedStatement의 경우 변수가 결과에 영향을 미치지 않는가
  - PreparedStatement의 경우 쿼리 문장 자체에 변수가 사용되기 때문에 쿼리 문장 자체로 쿼리 캐시를 찾을 수 없다.
  - 프로그램 코드에서 PreparedStatement를 사용했더라도 실제 MySQL 서버에서는 PreparedStatement 형태로 실행되지 않는다.
  - 제대로 된 PreparedStatement를 사용하기 위해서는 프로그램의 소스코드에서 데이터베이스 커넥션을 생성할 때 특별한 옵션을 사용해야 하며 이를 Server Side PreparedStatement라고 한다.
  - MySQL 5.0에서는 PreparedStatement로 실행된 쿼리는 쿼리 캐시를 사용할 수 없었지만 5.1 버전부터 해당 제약이 사라졌다.
- 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가
  - 쿼리 결과가 쿼리 캐시에 저장된 이후 데이터가 변경되면 변경된 데이터를 캐시하는 것은 의미가 없기 때문에 데이터를 제거해야 한다.
  - 쿼리 캐시에 있는 데이터를 무효화하는 작업은 테이블 단위로 처리된다.
  - 쿼리 캐시를 1GB로 아주 크게 설정하고 하나의 테이블로부터 조회된 데이트로 쿼리 캐시를 꽉 채웠다고 가정하자.
  - 해당 테이블에 새로운 레코드가 한 건 `INSERT` 되면 MySQL 서버는 캐시에 저장된 내용을 모두 제거해야 한다.
  - 이는 캐시의 용량이 클수록 많은 시간을 소모하게 된다.
  - 쿼리 캐시는 여러 스레드에서 동시에 변경할 수 없기 때문에 다른 스레드는 쿼리 캐시 삭제 작업이 완료될 때까지 기다려야 한다.
  - 때문에 적절한 크기 (32MB ~ 64MB)이상으로 설정할 경우 캐시 자체가 부하의 원인이 될 수 있다.
- 조회수를 보여주는 컬럼을 가지고 있는 경우
  - 애플리케이션에서는 항상 테이블로부터 `SELECT` 를 수행하기 이전에 `UPDATE` 를 수행하여 조회수를 증가시켜야 한다.
  - 이 테이블로부터 `SELECT` 한 결과를 쿼리 캐시에 저장했는데 `UPDATE` 쿼리에 의해 바로 삭제되는 현상이 발생한다.
  - 이 테이블은 쿼리 캐시를 사용할 수 없고 쿼리 캐시에 저장하고 삭제하는 오버헤드만 추가되는 꼴이 되버린다.
  - 이런 경우는 조회 컬럼을 다른 테이블로 분리하거나 조회수를 일정한 횟수만큼 누적한 후 한번에 업데이트하는 편이 좋다.
- 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가
  - 쿼리 캐시를 64MB로 설정했는데 쿼리 하나가 60MB 정도의 쿼리 결과를 만들어내면 하나의 쿼리 때문에 쿼리 캐시를 다 소모해 버릴 수 있다.
  - 이러한 현상을 예방하기 위해 일정 크기 미만의 쿼리 결과만 캐시하도록 설정하는 시스템 파라미터가 있다.
  - 설정 파라미터의 이름은 `query_cache_limit` 이며 값은 1MB ~ 2MB 미만으로 설정하는 것이 일반적이다.
  - 만들어진 쿼리의 결과가 작을 수록 캐시를 더욱 효율적으로 사용할수 있기 때문에 `GROUP BY` 나 `DISTINCT` , `COUNT` 와 같은 집합 함수의 결과가 쿼리 캐시를 사용하기에 적합하다.
- 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용되었는가
  - 임시 테이블에 대한 쿼리, 사용자 변수의 사용, 컬럼 기반의 권한 설정, LOCK IN SHARE MODE, FOR UPDATE, 사용자 정의 함수 사용, 일부분의 서브 쿼리, SQL_NO_CACHE 등을 사용하는 경우
- 쿼리 캐시를 사용하지 못하게 하는 수 많은 제약 사항이 있지만 쿼리 캐시를 사용함으로써 충분한 성능 향상을 얻을 수 있는 훌륭한 기능이다.
- MySQL 서버에서 실행되는 작업은 서버의 상태변수에 누적되어 기록되기 때문에 `SHOW GLOBAL STATUS` 명령어를 통해 쿼리 캐시가 얼마나 사용되었는지 확인할 수 있다.
- 쿼리 캐시의 히트율은 `QCache_hits / (QCache_hits + Com_select) * 100` 으로 구할 수 있으며 캐시 히트율이 20% 이상이면 쿼리 캐시를 사용하는 것이 좋다고 이야기 할 수 있다.
- 쿼리 캐시를 사용하지 않을 경우 `query_cache_size` 와 `query_cache_type` 을 0으로 설정해야 메모리 낭비 및 캐시를 검색하는 비용을 제거할 수 있다.



> 정리

- MySQL은 쿼리 캐시 기능을 제공하여 요청된 쿼리가 캐시에 존재할 경우 즉시 값을 반환할 수 있기 때문에 이를 통한 성능 향상을 얻을 수 있다.
- 쿼리 캐시는 Key와 Value의 쌍으로 구성되어 있으며 Key로는 공백 문자와 대소문자를 구별하는 쿼리 자체가 저장되고 Value에는 해당 쿼리를 실행한 결과가 저장된다.
- 쿼리 캐시에 저장된 데이터를 반환하기 위해서는 복잡한 확인 절차를 거쳐야 한다.
- 쿼리 캐시를 사용하기 위해서는 해당 데이터가 쿼리 캐시에 존재하는지 사용자가 테이블에 대한 권한을 가지고 있는지 확인할 뿐만 아니라
- 요청된 쿼리의 트랜잭션 가시성 여부, 호출 시점에 따라 변경 여부, 캐시된 데이터의 변경 여부, 캐시 하기에 충분한 크기인지 등의 요소를 고려하여야 한다.
