# 4.2 MySQL 엔진의 잠금

- 잠금은 트랜잭션과 비슷한 개념같지만 트랜잭션이 데이터의 정합성을 보장하기 위한 기능인 반면에 잠금은 동시성을 제어하기 위한 기능이라는 점에서 차이가 있다.
- MySQL에서의 잠금은 크게 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있다.
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에게 영향을 미치지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 상호간에 영향을 미치니는 않는다.

<br>

## 4.2.1 글로벌 락

- 글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로만 획득할 수 있으며 MySQL에서 제공하는 잠금 중에 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득하면 다른 세션에서 `SELECT` 를 제외한 대부분의 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 때 까지 대기 상태로 남는다.
- 글로벌 락이 영향을 미치는 범위는 MySQL 서버 전체이며 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
- 글로벌 락은 여러 데이터베이스에 존재하는 MyISAM이나 Memory 테이블에 대해 `mysqldump` 로 일관된 백업을 받아야 할때 사용한다.
- 장시간 실행되는 쿼리와 글로벌 락 명령이 최악의 케이스로 실행되면 MySQL 서버의 모든 테이블에 대한 `INSERT` , `UPDATE` , `DELETE` 쿼리가 아주 오랜 시간동안 실행되지 못하고 기다려야한다.
- 글로벌 락은 MySQL서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스로 사용되는 서버에서는 가급적이면 사용하지 않는 것이 좋다.

<br>

> 정리

- 글로벌 락은 MySQL에서 제공하는 잠금 중에서 가장 범위가 넓으며 MySQL 서버 전체에 영향을 미친다.
- 글로벌 락은 `FLUSH TABLES WITH READ LOCK` 이라는 명령어로 획득할 수 있으며 글로벌 락이 수행되는 동안 `SELECT` 를 제외한 DDL, DML 문장을 실행하는 경우 글로벌 락이 해제될 때 까지 대기상태로 남는다.
- 글로벌락은 서버 전체에 영향을 미치기 때문에 작업 대상의 테이블이나 데이터베이스가 다르다고 하더라도 동일하게 영향을 미친다.
- 글로벌 락은 MySQL 서버의 모든 테이블에 큰 영향을 미치기 때문에 웹 서비스로 사용되는 서버에서는 가급적이면 사용하지 않는 것이 좋다.

<br>

## 4.2.2 테이블 락

- 개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.
- 명시적으로는 `LOCK TABLES table_name READ | WRITE` 명령으로 특정 테이블의 락을 획득할 수 있다.
- 테이블락은 MyISAM 뿐만아니라 InnoDB 스토리지 엔진을 사용하는 테이블에서도 동일하게 설정할 수 있다.
- 명시적으로 획득한 잠금은 `UNLOCK TABLES` 명령으로 잠금을 해제할 수 있으며 명시적인 테이블 락도 특별한 상황이 아니라면 애플리케이션에서 거의 사용할 일이 없다.
- 명시적으로 테이블을 잠그는 작업은 글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미친다.
- 묵시적인 테이블 락은 MyISAM이나 Memory 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.
- MySQL서버가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 다음 즉시 잠금을 해제하는 형태로 사용된다.
- 묵시적인 테이블 락은 쿼리가 실행되는 동안만 잠금을 획득하고 쿼리가 완료된 후에는 자동으로 해제된다.
- InnoDB 스토리지 엔진의 경우 레코드 기반의 잠금을 제공하기 때문에 단순 데이터 변경으로 인한 테이블 락이 설정되지 않는다.
- 정확히는 InnoDB 테이블에서도 테이블 락이 설정되지만 대부분의 DML 쿼리에서는 무시되고 스키마를 변경하는 DDL의 경우에만 영향을 미친다.

<br>

> 정리

- 테이블 락은 개별 테이블 단위로 설정되는 잠금이며 특정 명령어에 의한 명시적인 방법과 자동으로 락을 획득하는 묵시적인 방법으로 나누어진다.
- 명시적인 방법은 `LOCK TABLES table_name READ | WRITE` 명령으로 획득하고 `UNLOCK TABLES` 명령으로 잠금을 반환하며 글로벌 락과 마찬가지로 온라인 작업에 상당한 영향을 미치기 때문에 잘 사용하지 않는다.
- 묵시적인 테이블 락은 MyISAM 이나 Memory 테이블에 데이터를 변경하는 쿼리를 실행할 때 발생하며 쿼리가 수행된 다음에 자동으로 해제된다.
- InnoDB 스토리지 엔진은 레코트 기반의 락을 제공하기 때문에 단순 데이터 변경으로 인한 테이블락이 설정되지 않으며 대부분의 DML 쿼리에서는 무시되고 스키마를 변경하는 DDL의 경우에만 영향을 미친다.

<br>

## 4.2.3 유저 락

- 유저 락은 `GET_LOCK` 함수를 이용해 임의로 잠금을 설정할 수 있다.
- 유저 락의 특징은 대상이 테이블이나 레코드 또는 `AUTO_INCREMENT` 와 같은 데이터베이스 객체가 아니다.
- 유저 락은 단순히 사용자가 지정한 문자열에 대해 획득하고 반납하는 잠금이다.
- 유저 락은 자주 사용되지는 않으며 여러 클라이언트가 상호 동기화 처리를 해야할 경우나 많은 레코드를 한 번에 변경하는 트랜잭션의 경우에 유용하게 사용할 수 있다.
- 배치 프로그램처럼 한번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 된다.
- 각 프로그램의 실행 시간을 분산하여 데드락을 최소화 할 수는 있지만 간단한 방법이 아닐 뿐더러 완벽한 해결방법이 아니다.
- 이러한 경우에 동일 데이터를 변경하거나 참조하는 프로그램끼리 분리하여 유저 락을 걸고 쿼리를 실행하면 간단하게 해결할 수 있다.

<br>

> 정리

- 유저 락은 `GET_LOCK` 함수를 통해 임의로 잠금을 설정할 수 있으며 단순히 사용자가 지정한 문자열에 대한 잠금을 획득하고 반환한다.
- 유저 락은 클라이언트 상호 동기화 처리나 배치 프로그램 처럼 한번에 많은 레코드를 변경하는 경우에 유용하게 사용된다.
- 이러한 경우 동일 데이터를 변경하거나 참조하는 프로그램끼리 분리하여 유저 락을 걸고 쿼리를 실행하는 방식으로 문제를 해결할 수 있다.

<br>

## 4.2.4 네임 락

- 테이블이나 뷰 등의 데이터베이스 객체의 이름을 변경하는 경우 획득하는 잠금이다.
- 명시적으로 획득하거나 해제할 수 있는 잠금이 아니며 테이블 이름을 변경하는 경우 자동으로 획득하는 잠금이다.
- `RENAME TABLE` 명령의 경우 원본 이름과 변경될 이름 두 개 모두 함꺼번에 잠금을 설정한다.
- 네임 락을 사용하는 경우에는 `Table not found` 오류를 발생시키는 것을 주의해야 한다.
- `RENAME TABLE A TO B, C To A` 와 같이 두 개의 `RENAME` 작업을 한번에 실행하면 오류가 발생하지 않지만.
- `REANME TABLE A TO B` , `RENAME TABLE C TO A` 와 같이 두개로 나누어 실행하게 되면 아주 짧은 시간이지만 `A` 테이블이 존재하지 않게 되므로 오류가 발생할 수 있다.

<br>

> 정리

- 네임 락은 테이블이나 뷰 등의 데이터베이스 객체의 이름을 변경하는 경우 획득하는 락이며 명시적으로 획득하거나 해제할 수 없다.
- `RENAME LOCK` 명령의 경우 원본 테이블과 변경될 이름의 테이블 두 개 모두 한번에 잠금을 설정한다.
- 네임 락을 사용하는 경우 `Table not found` 오류를 발생시키는 것에 주의해야 한다.
