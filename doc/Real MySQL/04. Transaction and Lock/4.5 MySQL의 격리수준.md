# 4.5 MySQL의 격리 수준

- 트랜잭션 격리 수준이란 동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.
- 즉, 격리 수준이라는 것은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것이인지를 결정하는 레벨을 의미한다.
- 트랜잭션 격리 수준은 크게 `READ_UNCOMMITED` , `READ_COMMITED` , `REPEATABLE_READ` , `SERIALIZABLE` 네 단계로 나누어진다.
- `DIRTY_READ` 라고도 불리는 `READ_UNCOMMITED` 는 일반 데이터베이스에서는 거의 사용되지 않고 `SERIALIZABLE` 또한 동시성이 중요한 데이터베이스에서는 거의 사용되지 않는다.
- 트랜잭션의 격리 수준에 따라 `DIRTY_READ` , `NON_REPEATABLE_READ` , `PHANTOM_READ` 세 가지의 부정합이 발생할 수 있다.
- 일반적인 온라인 서비스 용도의 데이터베이스에서는 `READ_COMMITED` 와 `REPEATABLE_READ` 격리 수준을 사용한다.

<br>

> 정리

- 트랜잭션 격리 수준이란 동시에 여러 트랜잭션이 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.
- 트랜잭션 격리 수준은 `READ_UNCOMMITED` , `READ_COMMITED` , `REPEATABLE_READ` , `SERIALIZABLE` 네 단계로 나누어지며 갈수록 격리 수준이 높아진다.
- 트랜잭션 격리 수준에 따라서 `DIRTY_READ` , `NON_REPEATABLE_READ` , `PHANTOM_READ` 세 가지의 부정합이 발생할 수 있다.
- 일반적인 온라인 서비스 용도의 데이터베이스에서는 `READ_COMMITED` 와 `REPEATABLE_READ` 격리수준을 사용한다.

<br>

## 4.5.1 READ UNCOMMITED

- `READ_UNCOMMITED` 격리 수준에서는 각 트랜잭션의 변경 내용이 `COMMIT` 이나 `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 보여지게 된다.
- 이처럼 어떠한 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 `DIRTY_READ` 라고 한다.
- `DIRTY_READ` 현상은 데이터가 나타났다 사라졌다 하는 현상을 초래하므로 애플리케이션 개발자와 클라이언트를 혼란흐럽게 만든다.
- `DIRTY_READ` 를 유발하는 `READ_UNCOMMITED` 는 RDBMS 표준에서 트랜잭션 격리 수준으로 인정하지 않으며 많은 정합성 문제를 일으킨다.

<br>

> 정리

- `READ_UNCOMMITED` 는 각 트랜잭션의 변경 내용이 `COMMIT` 이나 `ROLLBACK` 여부에 상관없이 다른 트랜잭션에서 보여진다.
- 이러한 `DIRTY_READ` 로 인하여 `READ_UNCOMMITED` 격리 수준에서는 데이터가 나타났다 사라졌다 하는 현상이 발생하므로 클라이언트와 애플리케이션 개발자를 혼란스럽게 만든다.

<br>

## 4.5.2 READ COMMITED

- `READ_COMMITED` 는 오라클 DBMS의 기본 격리수준으로 온라인 서비스에서 가장 많이 선택되는 격리 수준이다.
- `READ_COMMITED` 에서는 트랜잭션에서 데이터를 변경했더라도 `COMMIT` 이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문에 `DIRTY_READ` 가 발생하지 않는다.
- `READ_COMMITED` 격리 수준에서는 `NON_REPEATABLE_READ` 부정합 문제가 발생할 수 있다.
    - 한 트랜잭션에서 동일한 데이터를 두 번 조회하는 상황에서 다른 트랜잭션의 데이터 변경과 커밋이 그 사이에 일어났다고 가정하자.
    - 이 경우 동일 트랜잭션 내에서 조회하는 결과가 달라지게 되므로 하나의 트랜잭션 내에서 똑같은 `SEELCT` 쿼리를 실행했을 때 항상 같은 결과를 가져와야 한다는 `REPEATABLE_READ` 정합성에 어긋나게 된다.
- 이와 같은 부정합 현상은 일반적인 웹 프로그램에서는 크게 문제가 되지는 않지만 하나의 트랜잭션에서 여러번 데이터를 읽고 변경하는 금전적인 처리와 연결되는 문제가 될 수도 있다.

<br>

> 정리

- `READ_COMMITED` 격리 수준은 온라인 서비스에서 가장 많이 사용되는 격리 수준으로 트랜잭션에서 데이터를 변경하더라도 `COMMIT` 이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- `READ_COMMITED` 격리 수준에서는 동일 트랜잭션 내에서 조회 결과가 달라지는 `NON_REPEATABLE_READ` 부정합 문제가 발생할 수 있다.
- 이러한 부정합 문제는 일반적인 웹 프로그램에서는 문제가 되지 않지만 한 트랜잭션 내에서 여러번 데이터를 조회하고 변경하는 금전적인 처리에서는 문제가 될 수 있다.

<br>

## 4.5.3 REPEATABLE READ

- `REPEATABLE_READ` 는 MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용하는 격리 수준이다.
- 바이너리 로그를 가진 MySQL 장비에서는 최소 `REPEATABLE_READ` 이상 격리 수준을 사용해야 한다.
- `REPEATABLE_READ` 격리 수준에서는 트랜잭션이 `ROLLBACK` 될 가능성에 대비해 변경되기 전 레코드를 Undo 공간에 백업해두고 실제 레코드 값을 변경한다.
- `REPEATABLE_READ` 는 MVCC를 이용해 Undo 영역의 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다.
- 모든 InnoDB 트랜잭션은 고유한 번호를 가지며 Undo 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함된다.
- Undo 영역의 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.
- `REPEATABLE_READ` 격리 수준에서는 MVCC를 보장하기 위해서 실행중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 Undo 영역의 데이터는 삭제할 수 없다.
- 때문에 `REPEATABLE_READ` 에서는 위와 같은 동일 트랜잭션 내에서 여러번 조회가 일어나는 사이에 다른 트랜잭션에 의해 데이터가 변경되었더라도 해당 트랜잭션 번호보다 작은 트랜잭션 번호를 가진 데이터를 조회하게 된다.
- 하나의 트랜잭션이 장시간 지속된다면 Undo 영역이 백업 데이터르 무한정 커질 수도 있으며 이로인한 MySQL 서버의 처리 성능이 떨어질 수 있다.
- `REPEATABLE_READ` 격리 수준에서는 `PHANTOM_READ` 부정합 문제가 발생할 수 있다.
    - `SELECT ... FOR UPDATE` 쿼리는 `SELECT` 하는 레코드에 쓰기 잠금을 걸어야 하는데 Undo 레코드에는 잠금을 걸 수 없기 때문에 현재 레코드의 값을 가져오게 된다.
    - 때문에 위와 같은 쿼리로 여러번 조회하는 경우에는 중간에 다른 트랜잭션에 의해 변경된 데이터가 그대로 반영되어 서로 다른 결과를 나타낼 수 있다.

<br>

> 정리

- `REPEATABLE_READ` 격리 수준은 InnoDB 스토리지 엔진의 기본 격리 수준으로서 바이너리 로그를 가진 장비에서는 `REPEATABLE_READ` 이상의 격리 수준을 유지해야 한다.
- `REPEATABLE_READ` 는 MVCC를 이용해 Undo 영역의 데이터를 조회함으로써 현재 실행중인 트랜잭션 번호보다 낮은 트랜잭션에 의해 변경된 데이터만 조회가 가능하다.
- 하나의 트랜잭션이 장시간 지속된다면 Undo 영역이 무한정 증가할 수 있고 이로인해 MySQL의 성능이 떨어질 수 있다.
- `REPEATABLE_READ` 에서는 `PHANTOM_READ` 와 같은 부정합 문제가 발생할 수 있는데 이는 `SELECT ... FOR UPDATE` 쿼리와 같이 Undo 영역의 레코드 값을 조회할 수 없는 쿼리를 사용할 때 문제가 발생할 수 있다.

<br>

## 4.5.4 SERIALIZABLE

- 가장 단순하지만 가장 엄격한 격리 수준으로 그만큼 동시성 성능도 다른 트랜잭션 격리 수준에 비해 떨어진다.
- 일반적으로 InnoDB 스토리지 엔진의 테이블은 순수한 `SELECT` 작업에 대해서는 잠금없는 일관된 읽기를 제공하는데 `SERIALIZABLE` 격리 수준에서는 읽기 작업도 잠금을 획득해야 한다.
- 즉, `SERIALIZABLE` 격리 수준에서는 데이터를 읽고 쓰는 모든 작업을 수행하기 위해서 잠금을 획득해야 한다.
- InnoDB 스토리지 엔진에서는 `REPEATABLE_READ` 격리 수준에서도 `PHANTOM_READ` 가 발생하지 않기 때문에 굳이 `SERIALIZABLE` 격리 수준을 사용할 필요가 없다.

<br>

> 정리

- `SERIALIZABLE` 격리 수준은 가장 단순하지만 엄격한 격리 수준으로 모든 읽기와 쓰기 작업을 수행하기 위해서 잠금을 획득해야 한다.
- 때문에 다른 트랜잭션 격리 수준에 비해서 동시성 성능이 떨어진다.
- InnoDB 스토리지 엔진에서는 `REPEATABLE_READ` 격리 수준에서도 `PHANTOM_READ` 가 발생하지 않기 때문에 굳이 `SERIALIZABLE` 격리 수준을 사용할 필요가 없다.

<br>

## 4.5.5 REPEATABLE READ 격리 수준과 READ COMMITED 격리 수준의 성능 비교

- 하나의 트랜잭션이 오래 지속되면서 Undo 영역의 크기가 커져 MySQL의 성능을 떨어트리는 경우가 아니라면 `REPEATABLE_READ` 격리 수준과 `READ_COMMITED` 격리 수준의 차이는 크지 않다.
- 하지만 `STATEMENT` 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 `READ_COMMITED` 격리 수준을 사용할 수 없다.

<br>

### 격리 수준을 REPEATABLE READ 에서 READ COMMITED 로 낮추는 경우

- `STATEMENT` 포맷의 바이너리 로그를 사용하는 MySQL 서버에서는 `REPEATABLE_READ` 이상의 격리 수준을 사용하며 이 때 넥스트 키 락을 사용한다.
- 먼저 행 단위의 잠금인 Shared Lock 과 Exclusive Lock에 대해서 알아보자.
    - Shared Lock은 `READ` 에 대한 잠금으로 일반적으로 `SELECT` 쿼리는 잠금을 사용하지 않고 데이터베이스를 읽는데 일부 `SELECT` 에서는 읽기 작업 수행시 각 행 단위로 잠금을 건다.
    - Exclusive Lock은 `WRITE` 에 대한 잠금으로 DDL 쿼리를 수행할 때 행 단위로 잠금을 건다.
    - Shared Lock의 경우 동시에 한 행에 여러 트랜잭션에 잠금을 걸 수 있는데 이는 곧 동시에 여러 트랜잭션이 한 행을 읽을 수 있다는 의미이다.
    - 문제는 Shared Lock 상태에서 다른 트랜잭션이 Exclusive Lock을 시도할 수 없다는 것이다.
    - 또한 Exclusive Lock이 걸려있는 행에는 다른 트랜잭션이 Shared Lock이나 Exclusive Lock을 걸 수 없다.
- 만약 현재 트랜잭션에서 `SELECT` 실행시 대상 행에 대한 공유 잠금이 트랜잭션이 종료할 때 까지 발생하게 되는데 다른 트랜잭션이 대상 행에 대한 변경을 시도하면 데드락이 발생할 수 있다.
- 즉, 데드락이란 한 트랜잭션에서 공유 잠금이 발생한 행에 대해 다른 트랜잭션이 쓰기를 시도하면서 발생하는 현상인데 이를 `READ_COMMITED` 격리 수준으로 낮추어 해결할 수 있다.
- `READ_COMMITED` 격리 수준에서는 해당 행에 대한 잠금이 쿼리가 종료할 때 까지만 발생하므로 다른 트랜잭션에서 대상 행에 대한 변경을 시도할 경우 데드락이 발생할 경우가 적다.
- 때문에 극도의 동시성을 요구하는 쓰기 작업을 수행하는 애플리케이션이라면 `READ_COMMITED` 격리 수준을 사용하는 것이 좋다.
