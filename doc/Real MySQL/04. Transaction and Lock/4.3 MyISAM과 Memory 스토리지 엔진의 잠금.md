# 4.3 MyISAM과 Memory 스토리지 엔진의 잠금

- MyISAM이나 Memory 스토리지 엔진은 자체적인 잠금을 가지지 않고 MySQL 엔진에서 제공하는 테이블 락을 그대로 사용한다.
- MyISAM이나 Memory 스토리지 엔진에서는 쿼리 단위로 필요한 잠금을 한꺼번에 요청해서 획득하기 때문에 데드락이 발생할 수 있다.

<br>

## 4.3.1 잠금 획득

- 읽기 잠금은 테이블에 쓰기 잠금이 걸려있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업을 수행할 수 있다.
- 쓰기 잠금은 테이블에 아무런 잠금이 걸려있지 않아야만 쓰기 잠금을 획득할 수 있고 그렇지 않다면 다른 잠금이 해제될 때 까지 기다려야 한다.

<br>

## 4.3.2 잠금 튜닝

- 테이블 락에 대한 작업상황은 MySQL 상태변수를 통해서 알 수 있다.
- `Table_locks_immediate` 는 다른 잠금이 풀리기를 기다리지 않고 바로 잠금을 획득한 횟수이다.
- `Table_locks_waited` 는 다른 잠금이 이미 해당 테이블을 사용하고 있어서 기다리던 횟수를 누적해서 저장하고 있다.
- 두 상태값의 비율을 통해 테이블 잠금을 대기하는 쿼리가 어느정도인지 알 수 있다.
- 이를 통해 테이블 잠금 때문에 경합이 많이 발생하고 있으면 테이블을 분리하거나 InnoDB 스토리지 엔진으로 변환하는 방법을 고려해보아야 한다.
- InnoDB 스토리지 엔진의 경우 레코드 단위의 잠금을 사용하기 때문에 집계에 포함되지 않는다.

<br>

> 정리

- 테이블락에 대한 작업상황은 MySQL 상태변수를 통해 알 수 있으며 잠금을 즉시 획득한 횟수와 대기 횟수의 비율을 통해 잠금을 대기하는 쿼리가 어느정도인지 알 수 있다.
- 이를 통해 경합이 많이 발생하고 있으면 테이블을 분리하거나 InnoDB 스토리지 엔진으로 변환하는 방법을 고려해보아야 한다.

<br>

## 4.3.3 테이블 수준의 잠금 확인 및 해제

- MyISAM과 Memory 등의 스토리지 엔진을 사용하는 테이블은 모두 테이블 단위의 잠금을 사용한다.
- 때문에 테이블의 잠금을 해제하지 않으면 다른 클라이언트에서 해당 테이블을 사용하는 것이 불가능하다.
- 하나의 테이블에서 전혀 다른 레코드라고 하더라도 동시에 변경하는 것은 불가능하기 때문에 쿼리의 동시 처리 성능이 떨어지게 된다.
- MySQL에서 테이블의 잠금을 획득하는 방법은 `LOCK TABLES` 명령을 이용해 명시적으로 획득하는 방법과 `SELECT` , `INSERT` , `DELETE` , `UPDATE` 등의 DDL 문장을 이용해 묵시적으로 획득하는 방법이 있다.
- 묵시적으로 잠금을 획득하는 방법은 쿼리가 실행되는 동안만 잠금을 획득하며 명시적인 잠금 방법은 `UNLOCK TABLES` 명령으로 해제하기 전에는 자동으로 해제되지 않는다.

<br>

> 정리

- MyISAM과 Memory 스토리지 엔진은 MySQL 엔진에서 제공하는 테이블 단위의 잠금을 사용한다.
- 테이블 잠금을 획득하는 방법은 명령어를 통한 명시적인 방법과 DDL 쿼리를 통한 묵시적인 방법으로 나누어진다.
- 묵시적인 방법의 잠금은 해당 쿼리가 종료될 떄 자동으로 잠금을 해제하지만 명시적인 잠금은 명령어를 통해 잠금을 해제해야 한다.
- 테이블 단위의 잠금은 해당 테이블의 잠금이 활성화 되어있는 동안 다른 클라이언트에서 해당 테이블에 대한 사용이 불가능하다.
- 이와 같은 이유 때문에 테이블 수준의 잠금은 쿼리의 동시 처리 성능을 크게 떨어트린다.
