# 4.4 InnoDB 스토리지 엔진의 잠금

- InnoDB 스토리지 엔진에서 제공하는 잠금은 MySQL에서 제공하는 잠금과 별개로 스토리지 엔진 내부에서 레코드 기반의 잠금 방식을 탑재하고 있다.
- InnoDB는 레코드 기반의 잠금 방식 때문에 MyISAM 스토리지 엔진보다 훨씬 뛰어난 동시성 처리를 제공할 수 있다.

<br>

## 4.4.1 InnoDB의 잠금 방식

- 비관적 잠금 (Pessimistic Locking)
    - 비관적 잠금은 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라고 한다.
    - 비관적 잠금에서는 현재 변경하고자하는 레코드를 다른 트랜잭션에서도 변경할 수 있다라는 비관적인 가정을 하기 떄문에 먼저 잠금을 획득한다.
    - 높은 동시성 처리에는 비관적 잠금이 유리하며 InnoDB에서는 비관적 잠금 방식을 사용하고 있다.
- 낙관적 잠금 (Optimistic Locking)
    - 낙관적 잠금에서는 각 트랜잭션이 같은 레코드를 변경할 가능성이 희박할 것이라고 가정한다.
    - 떄문에 우선 변경 작업을 수행하고 마지막에 잠금 충돌이 있었는지 확인하여 문제가 발생했다면 `ROLLBACK` 처리하는 방식을 사용한다.

<br>

> 정리

- 비관적 잠금은 현재 변경하고자 하는 레코드를 다른 트랜잭션에서도 변경할 수 있다고 가정하고 먼저 레코드에 대한 잠금을 획득하고 변경하는 방식을 사용한다.
- 낙관적 잠금은 현재 변경하고자 하는 레코드르르 다른 트랜잭션에서 변경할 가능성이 적다고 가정하고 먼저 레코드를 변경하고 이후 충돌이 발생했으면 `ROLLBACK` 하는 방식을 사용한다.
- 높은 동시성 처리에는 비관적 잠금이 유리하며 InnoDB에서는 비관적 잠금 방식을 사용한다.

<br>

## 4.4.2 InnoDB의 잠금 종류

- InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 더 넓은 범위의 락으로 에스컬레이션되는 경우는 없다.
- InnoDB 스토리지 엔진에서는 레코드 잠금 뿐만 아니라 레코드와 레코드 사이의 간격을 잠그는 갭 락을 제공한다.
- 레코드 락 (Record Lock, Record Only Lock)
    - 레코드 자체만을 잠그는 락이며 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다.
    - 한가지 중요한 차이점은 InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드를 잠근다는 점이다.
    - 만약 인덱스가 하나도 없는 테이블이라고 하더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다.
    - InnoDB에서의 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용하지만 기본키 또는 유니크 인덱스에 의한 변경 작업은 레코드 자체에 대해서만 락을 건다.
- 갭 락 (Gap Lock)
    - 갭 락은 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.
    - 갭 락의 역할을 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어한다.
    - 갭 락은 개념일 뿐이며 자체적으로 사용되지는 않고 넥스트 키 락의 일부로서 사용된다.
- 넥스트 키 락 (Next Key Lock)
    - 레코드 락과 갭 락을 합쳐놓은 형태의 잠금을 의미한다.
    - 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.
    - 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.
    - 때문에 가능하다면 바이너리 로그 포맷을 `ROW` 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.
    - 하지만 `ROW` 포맷의 바이너리 로그는 잘 상용되지 않기 때문에 안정성을 확인하는 것이 어려우며 `STATEMENT` 포맷의 바이너리 로그에 비해 로그 파일의 크기가 커질 가능성이 있다.
- 자동 증가 락 (Auto Increment Lock)
    - MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 `AUTO_INCREMENT` 라는 속성을 제공한다.
    - `AUTO_INCREMENT` 컬럼이 사용된 테이블에 동시에 여러 레코드가 `INSERT` 되는 경우 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일련번호를 가져야한다.
    - InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 자동 증가 락이라는 테이블 수준의 잠금을 사용한다.
    - 자동 증가 락은 `INSERT` , `REPLACE` 등의 새로운 레코드를 저장하는 쿼리에서만 필요하며 값을 가져오는 순간에만 락이 걸렸다가 즉시 해제된다.
    - MySQL 5.0 이하 버전에서는 자동 증가 락은 테이블에서 단 하나만 존재하기 때문에 하나의 쿼리가 락을 걸게되면 나머지 쿼리는 락을 기다려야 한다.
    - 해당 버전에서 자동 증가 락을 명시적으로 획득하고 해제하는 방법은 존재하지 않으며 아주 짧은 시간동안만 걸렸다가 해제되는 잠금이기 때문에 문제가 되지 않는다.
    - MySQL 5.1 이상 버전에서는 `innodb_autoinc_lock_mode` 라는 파라미터를 이용하여 자동 증가 락의 방식을 변경할 수 있다.
        - `innodb_autoinc_lock_mode = 0` : MySQL 5.0과 동일한 잠금 방식으로 모든 `INSERT` 문장은 자동 증가 락을 사용한다.
        - `innodb_autoinc_lock_mode = 1` : MySQL 서버가 `INSERT` 되는 레코드의 개수를 정확히 예측할 수 있을 때는 자동증가 락이 아닌 뮤텍스를 이용한 가벼운 잠금을 사용할 수 있다.
        - `innodb_autoinc_lock_mode = 2` : InnoDB 스토리지 엔진은 항상 뮤텍스를 이용하게 된다. 하지만 이 설정에서는 하나의 `INSERT` 문장으로 `INSERT` 되는 레코드라고 하더라도 연속된 자동 증가 값을 보장하지는 않는다.
    - 자동 증가 값은 한번 증가하면 절대 줄어들지 않으며 이는 자동 증가 락을 최소화하기 위해서이다.
    - 때문에 `INSERT` 쿼리가 실패했더라도 한번 증가된 자동 증가 값은 줄어들지 않고 그대로 남는다.

<br>

> 정리

- InnoDB는 레코드 기반의 잠금을 사용하여 동시성 처리 성능을 높이고 있다.
- InnoDB 스토리지 엔진은 레코드 락 뿐만 아니라 갭 락, 넥스트 키 락, 자동 증가 락 등의 여러가지 잠금을 제공한다.
- InnoDB에서의 레코드 락은 레코드 자체가 아닌 인덱스를 잠그는 방식으로 동작하며 인덱스가 없는 테이블이라고 하더라도 내부적으로 생성된 클러스터 인덱스를 이용한다.
- 갭 락은 레코드와 레코드 사이를 잠그는 락으로 레코드 사이에 새로운 데이터가 생성되는 것을 막는다.
- 갭 락은 자체적으로 사용하지 않고 네스트 키 락의 일부로서 사용된다.
- 넥스트 키 락은 레코드 락과 갭 락이 합쳐진 형태로 바이너리 로그에 기록된 쿼리가 슬레이브에 기록될 때 마스터에서 만들어낸 결과와 동일한 결과를 슬레이브에서 만들언내는 것을 목적으로 한다.
- 하지만 넥스트 키 락으로 인한 데드락 및 다른 트랜잭션이 대기하는 상황이 발생할 수 있으므로 `ROW` 기반의 바이너리 로그를 사용하여 이를 줄이는 것도 하나의 방법이다.
- 자동 증가 락은 `AUTO_INCREMENT` 컬럼 속성을 사용할 때 사용되는 테이블 수준의 락으로 해당 속성을 사용하는 테이블에 하나의 락이 존재한다.
- 자동 증가 락은 명시적으로 획득하거나 해제할 수 없으며 테이블 수준의 잠금을 사용하기 때문에 하나의 쿼리가 잠금을 걸게되면 다른 쿼리는 이를 기다려야 한다.
- 자동 증가 락은 값을 획득하는 아주 짧은 순간에만 잠금을 걸기 때문에 큰 문제가 되지는 않는다.
- MySQL 5.1 버전부터는 자동 증가 락의 작동 방식을 변경할 수 있으며 자동 증가 락 대신 경량화 되고 빠른 뮤텍스를 이용한 방법을 사용할 수 있다.
- 하지만 이는 하나의 `INSERT` 문장으로 생성되는 레코드라고 하더라도 연속된 자동 증가 값을 보장해주지 않기 때문에 마스터와 슬레이브의 자동 증가 값이 달라질 수 있어 주의해서 사용해야 한다.

<br>

## 4.4.3 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 동작한다.
- 즉, 변경해야할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.

<br>

### MySQL에서의 인덱스 잠금 예제

- `employees` 테이블에는 `first_name` 컬럼만 멤버로 담긴 `ix_firstname` 이라는 인덱스가 준비되어 있다.
- 아래와 같은 업데이트 쿼리를 실행했을 때 수행되는 결과와 동작을 확인해보자.
- `UPDATE employees SET hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen'`
- 업데이트 쿼리를 실행시키면 한 건의 레코드만 업데이트가 될 것이다.
- 해당 업데이트를 위해서 몇개의 레코드에 락을 걸어야 하는 것인지를 확인해보면 `first_name` 만을 인덱스로 활용할 수 있기 때문에 `first_name='Georgi'` 인 모든 레코드가 잠금 대상이 된다.
- `UPDATE` 쿼리를 위해서 적절히 인덱스가 준비되어있지 않다면 각 클라이언트 사이의 동시성이 떨어져서 한 세션에서 `UPDATE` 를 수행하는 중에 다른 클라이언트는 기다려야 하는 상황이 발생할 것이다.
- 만약 테이블에 인덱스가 하나도 없다면 테이블을 풀 스캔하면서 `UPDATE` 를 수행하는데 테이블의 모든 레코드를 잠그게 된다.
- 때문에 MySQL의 InnoDB에서 인덱스 설계가 중요한 이유가 바로 이 때문이다.

<br>

> 정리

- InnoDB 스토리지 엔진은 레코드 기반의 잠금을 제공하며 정확히는 레코드 자체를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 동작한다.
- 따라서 변경할 레코드를 찾기위해 검색한 인덱스의 레코드를 모두 잠그게 된다.
- 때문에 인덱스를 적절하게 설정하지 않는 경우 단 건의 업데이트를 위해서 다른 많은 레코드가 잠길 수 있으며 테이블의 인덱스가 없는 경우 테이블을 풀 스캔하면서 모든 레코드를 잠그게된다.
- 때문에 적절히 인덱스가 준비되어있지 않다면 클라이언트 사이의 동시성을 크게 떨어트리기 때문에 적절한 인덱스 설계가 중요하다.

<br>

## 4.4.4 트랜잭션 격리 수준과 잠금

- 위에서 언급한 것과 같이 인덱스를 잠그는 과정에서 불필요한 레코드까지 모두 잠기는 현상은 넥스트 키 락 때문에 발생하는데 이를 필요하게 하는 주요 원인은 복제를 위한 바이너리 로그 때문이다.
- `ROW` (레코드 기반의) 바이너리 로그를 사용하거나 바이너리 로그를 사용하지 않는 경우에는 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다.
- 넥스트 키 락이나 갭 락의 사용을 줄일 수 있다는 의미는 동시에 더 많은 사용자의 쿼리 요청을 처리할 수 있다는 의미이다.
- MySQL 5.0 이하의 버전에서는 바이너리 로그를 비활성화하지 않아도 트랜잭션 격리 수준을 `READ_COMMITED` 로 설정하는 것이 가능했다.
- MySQL 5.1 이상의 버전에서는 `STATEMENT` 기반의 바이너리 로그가 활성화되면 최소 `REPEATABLE_READ` 이상의 격리 수준을 강제하고 있다.
- 넥스트 키 락이나 갭 락이 없어진 상태에서는 `UPDATE` 쿼리가 수행되는 과정에도 조금 차이가 있다.
- 우선 인덱스를 기준으로 잠금을 걸게 되지만 그 다음 나머지 조건을 비교해서 일치하지 않는 레코드는 즉시 잠금을 해제한다.
- 때문에 결과적으로 실제 업데이트 대상이 되는 레코드에만 잠금을 가지게되며 비효율적으로 불필요한 잠금이 생기는 현상이 없어지게 된다.

<br>

> 정리

- InnoDB 스토리지 엔진의 레코드 기반의 잠금에서 불필요한 레코드까지 모두 잠기는 현상은 넥스트 키 락 때문에 발생하는데 넥스트 키 락이 필요한 주요 원인은 바이너리 로그 때문이다.
- `ROW` 기반의 바이너리 로그를 사용하거나 바이너리 로그를 비활성화 하는 경우에는 넥스트 키 락의 사용을 줄여서 동시성을 높일 수 있다.
- 넥스트 키 락이 없어진 상태에서는 우선 인덱스를 기준으로 잠금을 수행하지만 이후 나머지 조건에 해당하지 않는 레코드는 즉시 잠금을 해제하며 결과적으로는 변경 대상이 되는 레코드만 잠금을 가지게 된다.

<br>

## 4.4.5 레코드 수준의 잠금 확인 및 해제

- InnoDB 스토리지 엔진을 사용하는 테이블의 레코드 수준의 잠금은 테이블 수준의 잠금보다는 복잡하다.
- 테이블 수준의 잠금의 대상은 테이블 자체이기 떄문에 쉽게 문제의 원인이 발견되고 해결할 수 있다.
- 하지만 레코드 수준의 잠금은 테이블의 레코드 각각에 잠금이 걸리므로 오래 사용되지 않은 레코드는 잠금이 걸린 상태이더라도 쉽게 발견하기가 어렵다.
- MySQL 5.1이상 버전에서는 레코드 잠금과 잠금 대기에 대한 조회가 가능하다.

<br>

### MySQL 5.0 이하 버전에서의 잠금 확인 및 해제

- MySQL 5.0 이하 버전에서는 레코드 잠금 및 잠금 대기에 대한 조회가 불가능하기 때문에 직접 트랜잭션 상태를 조회하여 확인해야 한다.
- 이 때 레코드를 오랜시간동안 잠그고 있는 활성화된 트랜잭션인지를 확인해야 한다.
- 하지만 정확히 각 트랜잭션이 정확히 어떠한 잠금을 사용하는지는 알려주지는 않기 때문에 트랜잭션이 활성화된 프로세스에서 실행 중인 쿼리로 예측을 해야한다.
- 일반적으로 활성 상태이지만 아무런 SQL도 실행하지 않거나 다른 테이블의 레코드를 기다리고 있는 트랜잭션이 있다면 문제의 원인일 가능성이 높기 때문에 `KILL` 명령으로 종료해야 한다.
- 만약 근본적인 원인에 해당하는 트랜잭션을 찾는 것이 어렵다면 오래 기다리고 있는 트랜잭션의 커넥션을 모두 종료하는 것이 빠른 해결책이다.

<br>

### MySQL 5.1 이상 버전에서의 잠금 확인 및 해제

- MySQL 5.1 버전부터는 잠금과 잠금을 대기하고 있는 트랜잭션에 대한 메타정보를 제공한다.
- `INNODB_LOCKS` 테이블은 어떤 잠금이 존재하는지를 관리한다.
- `INNODB_TRX` 테이블은 어떤 트랜잭션이 어떤 클라이언트에 의해 기동되고 있으며 어떤 잠금을 기다리고 있는지를 관리한다.
- `INNODB_LOCK_WAITS` 테이블은 잠금에 의한 프로세스 간의 의존 관계를 관리한다.
- 위의 테이블들을 조합해서 어떤 커넥션이 어떤 커넥션을 기다리는지를 알아낼 수 있다.

<br>

> 정리

- MySQL 5.0 이전의 버전에서는 잠금 및 잠금 대기에 대한 조회가 불가능하기 때문에 직접 트랜잭션 상태정보를 통해 이를 확인해야 했다.
- MySQL 5.1 버전에서는 잠금 및 잠금 대기에 대한 메타정보를 테이블을 통해 제공하고 있으므로 각 테이블을 조합하여 SQL을 통해 어떤 커넥션이 어떤 커넥션을 기다리는지를 알아낼 수 있다.
