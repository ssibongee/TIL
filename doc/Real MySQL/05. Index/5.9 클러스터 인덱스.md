# 5.9 클러스터링 인덱스

- 클러스터란 여러개를 하나로 묶는다는 의미에서 주로 사용되며 인덱스의 클러스터링도 이 의미를 크게 벗어나지 않는다.
- 인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현되는데 비슷한 값들을 동시에 조회하는 경우가 많다는점에서 착안한 것이다.
- MySQL에서 클러스터링 인덱스는 InnoDB, TokuDB 스토리지 엔진에서만 지원하며 나머지 스토리지 엔진에서는 지원하지 않는다.

<br>

## 5.9.1 클러스터링 인덱스

- 클러스터링 인덱스는 테이블의 기본키에 대해서만 적용되는 내용이며 즉, 기본키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다.
- 중요한 것은 기본키 값에 의해 레코드의 저장 위치가 결정된다는 것인데 기본키 값이 변경되는 해당 레코드의 물리적인 저장 위치가 변경되어야 한다는 의미이다.
- 기본키 값으로 컬러스터링된 테이블은 기본키 값 자체에 대한 의존도가 상당히 높기 때문에 기본키를 무엇으로 설정하는지가 상당히 중요하다.
- 클러스터링 인덱스는 기본키 값에 의해 레코드 저장위치가 결정되기 때문에 인덱스 알고리즘이라기 보다는 테이블 레코드의 저장 방식이라고 볼 수 있다.
- 일반적으로 InnoDB같이 클러스터링 인덱스로 저장되는 테이블은 기본키 기반의 검색이 매우 빠르며 대신 레코드의 저장이나 기본키의 변경이 상대적으로 느릴 수 밖에 없다.
- 클러스터링 인덱스의 구조를 보면 클러스터링 테이블 구조 자체는 일반 `B-Tree` 와 많이 닮아있지만 `B-Tree` 의 리프노드와 달리 클러스터링 인덱스의 리프 노드에는 모든 컬럼이 같이 저장되어있다.
- 즉, 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리된다는 것이다.
- InnoDB를 제외한 테이블의 데이터 레코드는 기본키나 인덱스 키 값이 변경된다고해서 실제 데이터 레코드의 위치가 변경되지 않는다.
- 데이터 레코드가 `INSERT` 될 때 데이터 파일의 끝 또는 임의의 빈 공간에 저장되는데 이렇게 한번 결정된 위치는 절대 변경되지 않고 레코드의 주소는 MySQL 내부적으로 레코드를 식별하는 아이디로 인식된다.
- 기본키가 없는 InnoDB 테이블은 InnoDB 스토리지 엔진이 다음 우선순위대로 기본키를 대체할 컬럼을 선택한다.
    - 기본키가 있으면 기본키를 클러스터 키로 선택한다.
    - `NOT NULL` 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터 키로 선택한다.
    - 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 다음 클러스터 키로 선택한다.
- InnoDB 스토리지 엔진이 적절한 클러스터 키 후보를 찾지 못해서 내부적으로 자동 증가 컬럼을 추가한 경우 해당 컬럼은 사용자에게 노출되지 않으며 쿼리 문장에 명시적으로 사용할 수 없다.
- 즉, 기본키나 유니크 인덱스가 전혀 없는 InnoDB 테이블에서는 아무런 의미가 없는 숫자 값으로 클러스터링 되고 있으며 해당 인덱스는 아무런 혜택을 제공하지 않는다.
- 때문에 클러스터링 인덱스는 테이블별로 단 한번만 가질 수 있는 엄청난 혜택이기 때문에 가능하면 기본키를 명시하여 사용하는 것이 좋다.

<br>

> 정리

- 클러스터링 인덱스는 비슷한 기본키 값 끼리 묶어서 저장하는 것을 의미하며 기본키 값에 따라 물리적인 저장 위치가 결정된다.
- 클러스터링 인덱스는 기본키 값에 의해 레코드의 위치가 결정되기 때문에 테이블 레코드의 저장 방식으로 볼 수 있으며 리프 노드에 모든 컬럼이 같이 저장되어 있다.
- 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되며 InnoDB 스토리지 엔진에서는 기본키가 존재하지 않는 경우에 `NOT NULL` 옵션의 유니크 인덱스 중에서 선택하거나 임의로 자동 증가하는 컬럼을 만들어 사용한다.

<br>

## 5.9.2 보조 인덱스에 미치는 영향

- MyISAM이나 Memory 테이블과 같은 클러스터링 되지 않은 테이블은 `INSERT` 될 때 한번 저장된 공간에서 절대 이동하지 않는다.
- 데이터 레코드가 저장된 주소는 내부적인 레코드 아이디 역할을 하는데 기본키나 보조 인덱스의 각 키는 그 주소를 이용해 실제 데이터 레코드를 찾아온다.
- MyISAM 테이블이나 Memory 테이블에서 기본키와 보조 인덱스는 구조적으로 아무런 차이가 없다.
- InnoDB 테이블에서 보조 인덱스가 실제 레코드가 저장된 주소를 가지고 있다면 클러스터 키 값이 변경될 때 마다 데이터의 레코드 주소가 변경되고 해당 테이블의 모든 인덱스에 저장된 주소 값을 변경해야 한다.
- 이런 번거로움을 방지하고자 InnoDB 클러스터 테이블의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 기본키 값을 저장하도록 구현되어 있다.

<br>

```sql
SELECT *
FROM employees
WHERE first_name = 'Aamer'
```

<br>

- 위의 쿼리를 실행하는 경우 기본키로 클러스터링 된 InnoDB와 그렇지 않은 MyISAM에서 어떠한 차이가 존재하는지 알아보자.
    - MyISAM의 경우 인덱스를 검색해서 레코드의 주소를 확인한 다음 레코드의 주소를 이용해 최종 레코드를 가져온다.
    - InnoDB의 경우 인덱스를 검색해 레코드의 기본키 값을 확인한 다음 기본키 값을 이용해 다시한번 테이블을 검색한 후 최종 레코드를 가져온다.
- InnoDB가 MyISAM보다 조금 더 복잡하게 처리되지만 InnoDB 테이블에서 기본키로 레코드를 읽어오는 과정은 매우 빠르게 처리되기 때문에 성능을 걱정할 필요가 없다.

<br>

> 정리

- InnoDB를 제외한 다른 클러스터링 되지 않은 테이블은 `INSERT` 될 때 저장된 공간에서 절대 이동하지 않으며 해당 레코드가 저장된 주소를 기준으로 기본키나 보조 인덱스가 실제 데이터 레코드를 조회한다.
- 때문에 MyISAM이나 Memory 테이블에서는 기본키와 보조 인덱스가 구조적으로 아무런 차이를 가지지 않는다.
- InnoDB 테이블에서는 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 기본키 값을 저장하도록 구현되어 있으며 인덱스를 검색해 레코드의 기본키 값을 확인한 다음 기본키 값을 이용해 테이블을 조회하는 방식으로 동작한다.

<br>

## 5.9.3 클러스터 인덱스의 장점과 단점

- 클러스터 인덱스를 사용함으로써 얻을 수 있는 장점들은 다음과 같다.
    - 기본키로 검색할 때 성능이 우수하며 특히 기본키를 범위 검색하는 경우 매우 빠르게 동작한다.
    - 테이블의 모든 보조 인덱스가 기본키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.
- 클러스터 인덱스를 사용함으로써 생기는 단점들은 다음과 같다.
    - 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키 값의 크기가 클 경우 전체적으로 인덱스 크기가 커진다.
    - 보조 인덱스를 통해 검색할 때 기본키로 다시 한번 검색해야 하므로 처리 성능이 조금 느리다.
    - `INSERT` 할 때 기본키에 의해 레코드 저장위치가 결정되기 때문에 처리 성능이 느리다.
    - 기본키를 변경할 때 레코드를 `DELETE` 하고 `INSERT` 하는 작업이 필요하기 때문에 처리 성능이 느리다.

<br>

> 정리

- 클러스터 인덱스는 기본키를 기준으로 검색을 하거나 인덱스 만으로 처리할 수 있는 경우 매우 우수한 성능을 보인다.
- 하지만 기본키 값의 크기가 커질 경우 인덱스의 크기가 같이 커질 수 있으며, 보조 인덱스를 통해 레코드를 조회하는 경우에도 기본키를 가지고 한번더 조회해야 한다.
- `INSERT` 할 때에도 기본키에 의해 저장 위치가 결정되기 때문에 처리 성능이 느리며 기본키를 변경하는 경우 `DELETE` 이후 `INSERT` 하는 작업이 필요하다.

<br>

## 5.9.4 클러스터 테이블 사용시 주의사항

- 클러스터 인덱스 키의 크기 (기본키의 크기)
    - 클러스터 테이블의 경우 모든 보조 인덱스가 기본키 값을 포함하기 때문에 기본키의 크기가 커지면 보조 인덱스도 자동으로 크기가 커진다.
    - 일반적으로 테이블에 보조 인덱스가 4 ~ 5개 정도 생성되는 것을 고려하면 보조 인덱스의 크기가 급격하게 증가하게 된다.
    - 5개의 보조 인덱스를 가지는 테이블의 기본키가 10바이트인 경우와 50바이트인 경우를 비교해보자.
    - 기본키가 10바이트인 경우 레코드 하나당 증가하는 인덱스의 크기는 50바이트이며 100만건의 레코드를 저장했을 때 증가하는 인덱스의 크기는 약 47MB이다.
    - 기본키가 50바이트인 경우 레코드 하나당 증가하는 인덱스의 크기는 250바이트이며 100만건의 레코드를 저장했을 때 증가하는 인덱스의 크기는 약 238MB이다.
    - 레코드가 약 천만건이 되면 1.9GB가 증가하며 인덱스가 커질수록 같은 성능을 내기 위해 그만큼 메모리가 더 필요해진다는 의미다.
- 기본키는 `AUTO_INCREMENT` 보다는 가능한 업무적인 컬럼으로 생성할 것
    - InnoDB의 기본키는 클러스터 키로 사용되며 이 값에 의해 레코드의 위치가 결정된다.
    - 기본키로 검색하는 경우 클러스터 되지 않은 테이블에 비해 매우 빠르게 처리될 수 있음을 의미한다.
    - MyISAM과 같은 경우 기본키로 어떠한 것을 선택해도 성능 차이가 별로 없을 수 있지만 InnoDB는 엄청난 차이를 만들어내며 기본키는 중요한 역할을 하기 때문에 대부분의 검색에서 빈번하게 사용된다.
    - 그러므로 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 해당 컬럼을 기본키로 설정하는 것이 좋다.
- 기본키는 반드시 명시할 것
    - 가능하면 `AUTO_INCREMENT` 컬럼을 이용해서라도 기본키를 설정하는 것이 좋다.
    - InnoDB에서 기본키를 정의하지 않으면 내부적으로 자동 증가 컬럼을 추가해 기본키로 설정하지만 이렇게 설정된 컬럼은 클라이언트가 조회할 수 없기 때문이다.
    - 기본키를 정의하지 않아도 내부적으로 `AUTO_INCREMENT` 컬럼을 생성해서 기본키로 사용하는 것은 동일하기 때문에 기왕이면 값을 사용할 수 있도록 명시적인 컬럼을 생성해서 기본키로 사용하는 것이 좋다.
- `AUTO_INCREMENT` 컬럼을 인조 식별자로 사용할 경우
    - 여러개의 컬럼이 합쳐져서 기본키가 만들어지는 경우 기본키의 크기가 길어질 때가 존재하는데 기본키의 크기가 길어도 보조 인덱스가 필요하지 않다면 그대로 기본키를 사용하는 것이 좋다.
    - 만약 보조 인덱스도 필요하고 기본키도 필요하다면 `AUTO_INCREMENT` 컬럼을 추가하고 이를 기본키로 설정하면된다.
    - 이렇게 기본키를 대체하기 위해 인위적으로 추가된 기본키를 인조 식별자라고 하며 로그 테이블 같이 조회보다는 `INSERT` 위주의 테이블들은 `AUTO_INCREMENT` 를 이용한 인조 식별자를 기본키로 설정하는 것이 성능향상에 도움이된다.

<br>

> 정리

- 클러스터 인덱스를 사용할 때에는 주의해야 할 사항이 몇가지 존재한다.
- 클러스터 인덱스 자체는 보조 인덱스가 실제 레코드를 조회하는 용도로 사용되기 때문에 클러스터 인덱스의 크기가 커지면 보조 인덱스의 크기가 커지기 때문에 이를 고려해야 한다.
- 클러스터 인덱스로 검색하는 쿼리는 매우 빠르게 처리될수 있으므로 업무적으로 해당 레코드를 대표할 수 있는 컬럼을 기본키로 설정하는 것이 좋다.
- 기본키는 설정하지 않아도 내부적으로 InnoDB에서 자동 증가 컬럼을 생성해서 기본키로 사용하지만 이를 실제 조회할 수 없기 때문에 명시적으로 자동 증가 컬럼을 생성해서 기본키로 설정하는 것이 좋다.
