# 5.11 외래키

- MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성할 수 있으며 외래키 제약 조건이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스까지 생성된다.
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.
- InnoDB의 외래키 관리에는 두 가지 중요한 특징이 존재한다.
    - 테이블의 변경으로 인한 쓰기 잠금이 발생하는 경우에만 잠금 경합이 발생한다.
    - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합을 발생시키지 않는다.

<br>

## 5.11.1 자식 테이블의 변경이 대기하는 경우

```sql
# Tx 1 BEGIN
UPDATE tb_parent
SET name = 'Kim'
WHERE id = 2

# Tx 2 BEGIN
UPDATE tb_child
SET pid = 2
WHERE id = 100

# Tx 1 ROLLBACK
```

<br>

- 부모 테이블에서 `UPDATE` 를 실행하면서 첫번째 커넥션이 부모 테이블의 `id` 가 2인 레코드에 대해서 쓰기 잠금을 획득한다.
- 자식 테이블에서 부모의 키를 참조하는 외래키인 `pid` 를 2로 변경하는 쿼리를 실행한다면 이 쿼리는 부모 테이블의 변경 작업이 완료될 때까지 대기한다.
- 그 다음 첫번째 커넥션에서 `ROLLBACK` 이나 `COMMIT` 으로 트랜잭션을 종료하면 대기중인던 두번째 커넥션의 작업이 즉시 처리되는 것을 확인할 수 있다.
- 즉, 자식 테이블의 외래키 컬럼의 변경은 부모 테이블의 확인이 필요한데 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려있는 경우 잠금이 해제될 때까지 대기하게 된다.
- 만약 자식 테이블의 외래키가 아닌 컬럼의 변경은 외래키로 인한 잠금이 발생하지 않으며 이는 InnoDB의 외래키 두번째 특성에 해당한다.

<br>

> 정리

- 부모 테이블에 쓰기 잠금이 걸려있는 경우 자식 테이블에서 부모 테이블의 키를 참조하는 외래키를 변경하는 쿼리를 실행한다면 잠금 대기가 발생한다.
- 작업은 부모 테이블에 대한 트랜잭션이 `COMMIT` 또는 `ROLLBACK` 에 의해 완료될 때까지 대기하게 되며 끝난 즉시 해당 작업을 수행하게 된다.
- 반면에 외래키가 아닌 다른 컬럼을 변경하는 경우에는 외래키로 인한 잠금 확장이 발생하지 않는다.

<br>

## 5.11.2 부모 테이블의 변경 작업이 대기하는 경우

```sql
# Tx 1 BEGIN
UPDATE tb_child
SET name = 'Kim'
WHERE id = 100

# Tx 2 BEGIN
DELETE FROM tb_parent
WHERE id = 1

# Tx 1 ROLLBACK
```

<br>

- 첫번째 커넥션에서 부모 키 1을 참조하는 자식 테이블의 레코드를 변경하면 자식 테이블의 레코드에 대해 쓰기 잠금을 획득한다.
- 이 상태에서 두번쨰 커넥션에서 부모 테이블의 레코드를 삭제하려고하면 해당 쿼리는 자식 테이블의 레코드에 대한 쓰기 잠금이 해제될 때까지 기다려야 한다.
- 이는 자식 테이블이 생성될 때 정의된 외래키 특성 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되도록 동작하기 때문이다.
- 데이터베이스에서 외래키를 물리적으로 생성하려면 이러한 현상들로 인한 잠금 대기까지 고려하여 개발하는 것이 좋다.
- 물리적으로 외래키를 생성하면 자식 테이블에 레코드가 추가되는 경우 해당 참조키가 부모 테이블에 있는지 확인하지만 물리적인 외래키의 고려사항은 이러한 체크 작업이 아니라 체크를 위해 연관 테이블에 읽기 잠금을 걸어야 한다는 것이다.
- 이렇게 잠금이 다른 테이블로 확장되면 그만큼 전체적으로 쿼리의 동시 처리 성능에도 영향을 미치게 된다.

<br>

> 정리

- 자식 테이블에 쓰기 잠금이 걸린 상태에서 부모 테이블에서 해당 레코드를 삭제하려는 경우에 `ON DELETE CASCADE` 옵션을 설정했다면 자식 테이블의 쓰기 잠금이 해제될 때 까지 기다려야한다.
- 데이터베이스에서 외래키를 물리적으로 생성하기 위해서는 이러한 현상들로 인한 잠금 대기까지 고려하여 개발해야하며 이 때 주의할 사항은 외래키가 연관 테이블에 있는지 확인하기 위해서 읽기 잠금을 걸어야한다는 것이다.
- 잠금이 다른 테이블로 확장되면 쿼리의 동시 처리 성능에도 영향을 미칠 수 있기 떄문에 이를 주의해서 사용해야 한다.
